; ZiLOG ZNEO ANSI C Compiler Release 1.11
; -nolocalcse -optsize -model=S -nomodsect -noregvar
; -reduceopt -debug -peephole -const=ROM -alias -fastcall
	FILE	"..\UART.C"
.debug "C"
	SEGMENT NEAR_BSS
_trans_buffer:
	DS	512
.define "trans_buffer"
.alias "_trans_buffer"
.class 147
.value _trans_buffer
.dim 512
.type 108
.type 0
.endef
	SEGMENT CODE
.begrec "fmt_type",16
.define "status"
.value 0
.class 8
.type 12
.type 0
.endef
.define "flags"
.value 1
.class 8
.type 12
.type 0
.endef
.define "size"
.value 2
.class 8
.type 12
.type 0
.endef
.define "chr"
.value 3
.class 8
.type 12
.type 0
.endef
.define "type"
.value 4
.class 8
.type 12
.type 0
.endef
.define "field_width"
.value 5
.class 8
.type 2
.type 0
.endef
.define "precision"
.value 6
.class 8
.type 2
.type 0
.endef
.define "set_begin"
.value 7
.class 8
.type 140
.type 0
.endef
.define "set_end"
.value 9
.class 8
.type 140
.type 0
.endef
.define "pad_whole"
.value 11
.class 8
.type 12
.type 0
.endef
.define "pad_pre_fract"
.value 12
.class 8
.type 12
.type 0
.endef
.define "pad_post_fract"
.value 13
.class 8
.type 12
.type 0
.endef
.define "pad_at"
.value 14
.class 8
.type 140
.type 0
.endef
.endrec "fmt_type"
.begrec "flt_info",12
.define "flags"
.value 0
.class 8
.type 12
.type 0
.endef
.define "exp"
.value 1
.class 8
.type 2
.type 0
.endef
.define "digits"
.value 2
.class 8
.dim 10
.type 108
.type 0
.endef
.endrec "flt_info"
	SEGMENT NEAR_BSS
_rec_buffer:
	DS	512
.define "rec_buffer"
.alias "_rec_buffer"
.class 147
.value _rec_buffer
.dim 512
.type 108
.type 0
.endef
_trans_buffer_size:
	DS	4*1
.define "trans_buffer_size"
.alias "_trans_buffer_size"
.class 147
.value _trans_buffer_size
.type 5
.type 0
.endef
_rec_buffer_size:
	DS	4*1
.define "rec_buffer_size"
.alias "_rec_buffer_size"
.class 147
.value _rec_buffer_size
.type 5
.type 0
.endef
_trans_buffer_current:
	DS	4*1
.define "trans_buffer_current"
.alias "_trans_buffer_current"
.class 147
.value _trans_buffer_current
.type 5
.type 0
.endef
_rec_buffer_current:
	DS	4*1
.define "rec_buffer_current"
.alias "_rec_buffer_current"
.class 147
.value _rec_buffer_current
.type 5
.type 0
.endef
_baud_rate:
	DS	4*1
.define "baud_rate"
.alias "_baud_rate"
.class 147
.value _baud_rate
.type 15
.type 0
.endef
;    1	#include "uart.h"
;    2	
;    3	#include <zneo.h>
;    4	#include <string.h>
;    5	#include <stdio.h>
;    6	#include <stdarg.h>
;    7	
;    8	#define BUFFER_SIZE 512
;    9	
;   10	#define FREQ         5529600UL  //use internal oscillator
;   11	#define DEFAULT_BAUD 57600UL    //our desired baud rate
;   12	
;   13	//alternate function enable for PA for uart0
;   14	#define PORTA_UART_RXD	0x10	
;   15	#define PORTA_UART_TXD	0x20
;   16	
;   17	#define UART_TXD_EN		0x80	//transmit enable
;   18	#define UART_RXD_EN		0x40	//receive enable
;   19	
;   20	#define UART_TRAN_RDY 0x04
;   21	
;   22	#define UART_IRQ_EN   0x18
;   23	
;   24	#define UART_IRQ_TRAN 0x08
;   25	#define UART_IRQ_REC  0x10
;   26	
;   27	static unsigned char trans_buffer[BUFFER_SIZE];
;   28	static unsigned char rec_buffer[BUFFER_SIZE];
;   29	
;   30	static volatile int trans_buffer_size;
;   31	static volatile int rec_buffer_size;
;   32	
;   33	static volatile int trans_buffer_current;
;   34	static volatile int rec_buffer_current;
;   35	
;   36	static unsigned long baud_rate;
	SEGMENT CODE
;   37	
;   38	void interrupt uart_receive(void)
;   39	{
_uart_receive:
.define "_uart_receive"
.value _uart_receive
.class 2
.type 65
.type 0
.endef
.begfunc "uart_receive",39,"_uart_receive"
.line 39
.define "c"
.class 1
.value -1
.type 12
.type 0
.endef
.define "buffer_loc"
.class 1
.value -5
.type 5
.type 0
.endef
	LINK	#5
	PUSHMLO	#255
;   40		int buffer_loc;
;   41		unsigned char c;
;   42	
;   43		c = U0RXD;
.line 43
	LD.SB	R0,57856:RAM
	LD.B	-1(R14),R0
;   44	
;   45		//so the echo is compatible with Windows, CR+LF
;   46		if(c == '\r' || c == '\n') {
.line 46
	LD	R0,#13
	CP.B	-1(R14),R0
	JP	EQ,_1_L_1
	LD	R0,#10
	CP.B	-1(R14),R0
	JP	NE,_1_L_2
_1_L_1:
;   47			c = '\n';
.line 47
	LD	R0,#10
	LD.B	-1(R14),R0
;   48			uart_putchar('\r');
.line 48
	LD	R1,#13
	CALL	_uart_putchar
;   49			uart_putchar('\n');	
.line 49
	LD	R1,#10
	CALL	_uart_putchar
;   50		}
;   51		//echo the character back
;   52		else {
.line 52
	JP	_1_L_4
_1_L_2:
;   53			uart_putchar(c);
.line 53
	LD.SB	R1,-1(R14)
	CALL	_uart_putchar
;   54		}
_1_L_4:
.line 54
;   55	
;   56		if(rec_buffer_size < BUFFER_SIZE) {
.line 56
	LD	R0,#512
	CP	_rec_buffer_size:RAM,R0
	JP	GE,_1_L_5
;   57			buffer_loc = (rec_buffer_current + rec_buffer_size) % BUFFER_SIZE;
.line 57
	LD	R0,_rec_buffer_current:RAM
	ADD	R0,_rec_buffer_size:RAM
	LD	R1,#512
	SDIV	R0,R1
	LD	-5(R14),R1
;   58			
;   59			rec_buffer[buffer_loc] = c;
.line 59
	LD.SW	R0,-3(R14)
	LD	R1,#_rec_buffer
	ADD	R0,R1
	LD.SB	R1,-1(R14)
	LD.B	(R0),R1
;   60			++rec_buffer_size;
.line 60
	INC	_rec_buffer_size:RAM
;   61		}
;   62	}
_1_L_5:
.line 62
	POPMLO	#255
	UNLINK	
	IRET	


;**************************** _uart_receive ***************************
;Name                         Addr/Register   Size   Type
;_rec_buffer                         STATIC    512   variable
;_rec_buffer_current                 STATIC      4   variable
;_rec_buffer_size                    STATIC      4   variable
;_uart_putchar                       IMPORT  -----   function
;buffer_loc                           R14-5      4   variable
;c                                    R14-1      1   variable


; Aggregate Stack Size: -5 (words)


.endfunc "uart_receive",62,"_uart_receive"
;   63	
;   64	void interrupt uart_transfer(void)
;   65	{
_uart_transfer:
.define "_uart_transfer"
.value _uart_transfer
.class 2
.type 65
.type 0
.endef
.begfunc "uart_transfer",65,"_uart_transfer"
	LINK	#0
	PUSHMLO	#3
;   66		if(trans_buffer_size) {
.line 66
	CPZ	_trans_buffer_size:RAM
	JP	EQ,_2_L_8
;   67			U0TXD = trans_buffer[trans_buffer_current];
.line 67
	LD.SW	R0,_trans_buffer_current+2:RAM
	LD	R1,#_trans_buffer
	ADD	R0,R1
	LD.SB	R0,(R0)
	LD.B	57856:RAM,R0
;   68	
;   69			trans_buffer_current = (trans_buffer_current + 1) % BUFFER_SIZE;
.line 69
	LD	R0,_trans_buffer_current:RAM
	ADD	R0,#1
	LD	R1,#512
	SDIV	R0,R1
	LD	_trans_buffer_current:RAM,R1
;   70			trans_buffer_size--;
.line 70
	LD	R0,_trans_buffer_size:RAM
	DEC	_trans_buffer_size:RAM
;   71		}
;   72	}
_2_L_8:
.line 72
	POPMLO	#3
	UNLINK	
	IRET	


;**************************** _uart_transfer ***************************
;Name                         Addr/Register   Size   Type
;_trans_buffer_current               STATIC      4   variable
;_trans_buffer                       STATIC    512   variable
;_trans_buffer_size                  STATIC      4   variable


; Aggregate Stack Size: 0 (words)


.endfunc "uart_transfer",72,"_uart_transfer"
;   73	
;   74	/*
;   75		Configure UART0.
;   76	 */
;   77	void init_uart(void)
;   78	{
_init_uart:
.define "_init_uart"
.value _init_uart
.class 2
.type 65
.type 0
.endef
.begfunc "init_uart",78,"_init_uart"
	LINK	#0
;   79		memset(rec_buffer, 0, BUFFER_SIZE);
.line 79
	LD	R1,#_rec_buffer
	LD	R2,#0
	LD	R3,#512
	CALL	_memset
;   80		memset(trans_buffer, 0, BUFFER_SIZE);
.line 80
	LD	R1,#_trans_buffer
	LD	R2,#0
	LD	R3,#512
	CALL	_memset
;   81	
;   82		// Set the alternate function on port A
;   83	    // Enable UART0 TxD0/RxD0 pins (bits 4 & 5)
;   84		PAAFH &= ~(PORTA_UART_TXD | PORTA_UART_RXD);
.line 84
	LD	R0,#-49
	AND.B	57604:RAM,R0
;   85	    PAAFL |= PORTA_UART_TXD | PORTA_UART_RXD;
.line 85
	LD	R0,#48
	OR.B	57605:RAM,R0
;   86	
;   87	    // Set the baud rate
;   88	    // BRG = freq/( baud * 16)
;   89	    U0BR = FREQ/((unsigned long)DEFAULT_BAUD * 16UL);
.line 89
	LD	R0,#6
	LD.W	57862:RAM,R0
;   90		baud_rate = DEFAULT_BAUD;
.line 90
	LD	R0,#57600
	LD	_baud_rate:RAM,R0
;   91	
;   92	    // U0 control
;   93	    // Transmit enable, Receive Enable, No Parity, 1 Stop
;   94	    U0CTL0 = UART_RXD_EN | UART_TXD_EN;
.line 94
	LD	R0,#192
	LD.B	57858:RAM,R0
;   95	    U0CTL1 = 0;
.line 95
	CLR.B	57859:RAM
;   96	
;   97		//set nominal priority
;   98		IRQ0ENH |= UART_IRQ_EN;
.line 98
	LD	R0,#24
	OR.B	57394:RAM,R0
;   99		IRQ0ENL &= ~UART_IRQ_EN;
.line 99
	LD	R0,#-25
	AND.B	57395:RAM,R0
;  100	
;  101		PAIMUX &= ~UART_IRQ_EN;		//Port A (0) for interrupts
.line 101
	AND.B	57614:RAM,R0
;  102		PAIEDGE &= ~UART_IRQ_EN;	//negedge (0) interrupt
.line 102
	AND.B	57615:RAM,R0
;  103	
;  104		SET_VECTOR(UART0_RX, uart_receive);
;  105		SET_VECTOR(UART0_TX, uart_transfer);
;  106	}
.line 106
	UNLINK	
	RET	


;**************************** _init_uart ***************************
;Name                         Addr/Register   Size   Type
;_SET_VECTOR                         IMPORT  -----   function
;_baud_rate                          STATIC      4   variable
;_trans_buffer                       STATIC    512   variable
;_rec_buffer                         STATIC    512   variable
;_memset                             IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "init_uart",106,"_init_uart"
;  107	
;  108	int uart_putchar(unsigned char c)
;  109	{
_uart_putchar:
.define "_uart_putchar"
.value _uart_putchar
.class 2
.type 69
.type 0
.endef
.begfunc "uart_putchar",109,"_uart_putchar"
	LINK	#5
.line 109
	LD.B	-1(R14),R1
.define "c"
.class 9
.value -1
.type 12
.type 0
.endef
.define "buffer_loc"
.class 1
.value -5
.type 5
.type 0
.endef
;  110		int buffer_loc;
;  111	
;  112		if(c == '\n') {
.line 112
	LD	R0,#10
	CP.B	-1(R14),R0
	JP	NE,_4_L_19
;  113			while(uart_putchar('\r')) { ; }
_4_L_10:
.line 113
	LD	R1,#13
	CALL	_uart_putchar
	CP	R0,#0
	JP	NE,_4_L_10
;  114		}
_4_L_19:
.line 114
;  115	
;  116		if(trans_buffer_size < BUFFER_SIZE) {
.line 116
	LD	R0,#512
	CP	_trans_buffer_size:RAM,R0
	JP	GE,_4_L_18
;  117			DI();
.line 117
	DI
;  118			
;  119			buffer_loc = (trans_buffer_current + trans_buffer_size) % BUFFER_SIZE;
.line 119
	LD	R0,_trans_buffer_current:RAM
	ADD	R0,_trans_buffer_size:RAM
	LD	R1,#512
	SDIV	R0,R1
	LD	-5(R14),R1
;  120			trans_buffer[buffer_loc] = c;
.line 120
	LD.SW	R0,-3(R14)
	LD	R1,#_trans_buffer
	ADD	R0,R1
	LD.SB	R1,-1(R14)
	LD.B	(R0),R1
;  121			trans_buffer_size++;
.line 121
	LD	R0,_trans_buffer_size:RAM
	INC	_trans_buffer_size:RAM
;  122	
;  123			//trigger the interrupt if already ready to transmit
;  124			if((U0STAT0 & UART_TRAN_RDY) && 
.line 124
	LD	R0,#4
	TM.B	57857:RAM,R0
	JP	EQ,_4_L_16
;  125			   ((IRQ0SET & UART_IRQ_TRAN) == 0)) {
.line 125
	LD	R0,#8
	TM.B	57393:RAM,R0
	JP	NE,_4_L_16
;  126				IRQ0SET |= UART_IRQ_TRAN;
.line 126
	OR.B	57393:RAM,R0
;  127			}
_4_L_16:
.line 127
;  128	
;  129			EI();
.line 129
	EI
;  130		}
;  131		else {
.line 131
	JP	_4_L_20
_4_L_18:
;  132			return 1;
.line 132
	LD	R0,#1
	JP	_4_L_21
;  133		}
_4_L_20:
.line 133
;  134	
;  135		return 0;
.line 135
	LD	R0,#0
;  136	}
_4_L_21:
.line 136
	UNLINK	
	RET	


;**************************** _uart_putchar ***************************
;Name                         Addr/Register   Size   Type
;_EI                                 IMPORT  -----   function
;_trans_buffer                       STATIC    512   variable
;_trans_buffer_current               STATIC      4   variable
;_DI                                 IMPORT  -----   function
;_trans_buffer_size                  STATIC      4   variable
;buffer_loc                           R14-5      4   variable
;c                                    R14-1      1   parameter


; Aggregate Stack Size: -5 (words)


.endfunc "uart_putchar",136,"_uart_putchar"
;  137	
;  138	unsigned char uart_getchar(void)
;  139	{
_uart_getchar:
.define "_uart_getchar"
.value _uart_getchar
.class 2
.type 76
.type 0
.endef
.begfunc "uart_getchar",139,"_uart_getchar"
.line 139
.define "c"
.class 1
.value -1
.type 12
.type 0
.endef
	LINK	#1
;  140		unsigned char c;
;  141	
;  142		if(rec_buffer_size) {
.line 142
	CPZ	_rec_buffer_size:RAM
	JP	EQ,_5_L_24
;  143			DI();
.line 143
	DI
;  144	
;  145			c = rec_buffer[rec_buffer_current];
.line 145
	LD.SW	R0,_rec_buffer_current+2:RAM
	LD	R1,#_rec_buffer
	ADD	R0,R1
	LD.SB	R0,(R0)
	LD.B	-1(R14),R0
;  146			rec_buffer_current = (rec_buffer_current + 1) % BUFFER_SIZE;
.line 146
	LD	R0,_rec_buffer_current:RAM
	ADD	R0,#1
	LD	R1,#512
	SDIV	R0,R1
	LD	_rec_buffer_current:RAM,R1
;  147			rec_buffer_size--;
.line 147
	LD	R0,_rec_buffer_size:RAM
	DEC	_rec_buffer_size:RAM
;  148	
;  149			EI();
.line 149
	EI
;  150	
;  151			return c;
.line 151
	LD.SB	R0,-1(R14)
	JP	_5_L_25
;  152		}
_5_L_24:
.line 152
;  153	
;  154		return 0;
.line 154
	LD	R0,#0
;  155	}
_5_L_25:
.line 155
	UNLINK	
	RET	


;**************************** _uart_getchar ***************************
;Name                         Addr/Register   Size   Type
;_EI                                 IMPORT  -----   function
;_rec_buffer_current                 STATIC      4   variable
;_rec_buffer                         STATIC    512   variable
;_DI                                 IMPORT  -----   function
;_rec_buffer_size                    STATIC      4   variable
;c                                    R14-1      1   variable


; Aggregate Stack Size: -1 (words)


.endfunc "uart_getchar",155,"_uart_getchar"
;  156	
;  157	void uart_printf(const char *format, ...)
;  158	{
_uart_printf:
.define "_uart_printf"
.value _uart_printf
.class 2
.type 65
.type 0
.endef
.begfunc "uart_printf",158,"_uart_printf"
.line 158
.define "format"
.class 9
.value 8
.type 140
.type 0
.endef
.define "args"
.class 1
.value -2
.type 140
.type 0
.endef
.define "buffer"
.class 1
.value -514
.dim 512
.type 108
.type 0
.endef
	LINK	#0
	SUB	R15,#514
;  159		char buffer[BUFFER_SIZE];
;  160		va_list args;
;  161		int i;
;  162	
;  163		va_start(args, format);
.line 163
	LEA	R0,10(R14)
	LD.W	-2(R14),R0
;  164		vsprintf(buffer, format, args);
.line 164
	LEA	R1,-514(R14)
	LD.SW	R2,8(R14)
	LD.SW	R3,-2(R14)
	CALL	_vsprintf
;  165		va_end(args);
;  166	
;  167		uart_transfer_msg(buffer);
.line 167
	LEA	R1,-514(R14)
	CALL	_uart_transfer_msg
;  168	}
.line 168
	UNLINK	
	RET	


;**************************** _uart_printf ***************************
;Name                         Addr/Register   Size   Type
;_uart_transfer_msg                  IMPORT  -----   function
;_vsprintf                           IMPORT  -----   function
;buffer                             R14-514    512   variable
;args                                 R14-2      2   variable
;format                               R14+8      2   parameter


; Aggregate Stack Size: -514 (words)


.endfunc "uart_printf",168,"_uart_printf"
;  169	
;  170	void uart_transfer_msg(char *text)
;  171	{
_uart_transfer_msg:
.define "_uart_transfer_msg"
.value _uart_transfer_msg
.class 2
.type 65
.type 0
.endef
.begfunc "uart_transfer_msg",171,"_uart_transfer_msg"
	LINK	#8
.line 171
	LD.W	-2(R14),R1
.define "text"
.class 9
.value -2
.type 140
.type 0
.endef
.define "msg"
.class 1
.value -4
.type 140
.type 0
.endef
.define "i"
.class 1
.value -8
.type 5
.type 0
.endef
;  172		int i;
;  173		char *msg;
;  174		
;  175		msg = text;
.line 175
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
	JP	_7_L_33
;  176		for(i = 0; *msg && i < BUFFER_SIZE; i++) {
_7_L_34:
.line 176
	LD.SW	R0,-4(R14)
	CPZ.B	(R0)
	JP	EQ,_7_L_37
	LD	R0,#512
	CP	-8(R14),R0
	JP	LT,_7_L_29
	JP	_7_L_37
_7_L_33:
	CLR	-8(R14)
	JP	_7_L_34
;  177			while(uart_putchar(*msg)) { ; }	//wait if the buffer is full
_7_L_29:
.line 177
	LD.SW	R0,-4(R14)
	LD.SB	R1,(R0)
	CALL	_uart_putchar
	CP	R0,#0
	JP	NE,_7_L_29
;  178			msg++;
.line 178
	INC.W	-4(R14)
	INC	-8(R14)
;  179		}
.line 179
	JP	_7_L_34
;  180	}
_7_L_37:
.line 180
	UNLINK	
	RET	


;**************************** _uart_transfer_msg ***************************
;Name                         Addr/Register   Size   Type
;_uart_putchar                       IMPORT  -----   function
;i                                    R14-8      4   variable
;msg                                  R14-4      2   variable
;text                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "uart_transfer_msg",180,"_uart_transfer_msg"
;  181	
;  182	unsigned long uart_get_baud_rate(void)
;  183	{
_uart_get_baud_rate:
.define "_uart_get_baud_rate"
.value _uart_get_baud_rate
.class 2
.type 79
.type 0
.endef
.begfunc "uart_get_baud_rate",183,"_uart_get_baud_rate"
	LINK	#0
;  184		return baud_rate;
.line 184
	LD	R0,_baud_rate:RAM
;  185	}
.line 185
	UNLINK	
	RET	


;**************************** _uart_get_baud_rate ***************************
;Name                         Addr/Register   Size   Type
;_baud_rate                          STATIC      4   variable


; Aggregate Stack Size: 0 (words)


.endfunc "uart_get_baud_rate",185,"_uart_get_baud_rate"
	VECTOR	UART0_TX=_uart_transfer
	VECTOR	UART0_RX=_uart_receive
	XREF _vsprintf:EROM
	XREF _memset:EROM
	XDEF _uart_get_baud_rate
	XDEF _uart_transfer_msg
	XDEF _uart_printf
	XDEF _uart_getchar
	XDEF _uart_putchar
	XDEF _init_uart
	XDEF _uart_transfer
	XDEF _uart_receive
	END
