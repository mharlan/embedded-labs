; ZiLOG ZNEO ANSI C Compiler Release 1.11
; -nolocalcse -optsize -model=S -nomodsect -noregvar
; -reduceopt -debug -peephole -const=ROM -alias -fastcall
	FILE	"..\CLI.C"
.debug "C"
	SEGMENT NEAR_BSS
_cli_prompt:
	DS	256
.define "cli_prompt"
.alias "_cli_prompt"
.class 147
.value _cli_prompt
.dim 256
.type 108
.type 0
.endef
	SEGMENT CODE
.begrec "NONAME0",8
.define "quot"
.value 0
.class 8
.type 5
.type 0
.endef
.define "rem"
.value 4
.class 8
.type 5
.type 0
.endef
.endrec "NONAME0"
.begrec "NONAME1",8
.define "quot"
.value 0
.class 8
.type 5
.type 0
.endef
.define "rem"
.value 4
.class 8
.type 5
.type 0
.endef
.endrec "NONAME1"
	SEGMENT ROM_TEXT
L__0:
	DB	"> "
	DB	0
;    1	#include "cli.h"
;    2	#include "LED.h"
;    3	#include "uart.h"
;    4	#include "info.h"
;    5	#include "macro.h"
;    6	#include "ports.h"
;    7	#include "timer.h"
;    8	
;    9	#include <stdlib.h>
;   10	#include <string.h>
;   11	#include <ctype.h>
;   12	
;   13	#define CLI_PROMPT      "> "
;   14	#define CLI_BUFFER_SIZE 256
;   15	
;   16	#define ASCII_DEL 0x7F
;   17	
;   18	static char cli_prompt[CLI_BUFFER_SIZE];
	SEGMENT CODE
;   19	
;   20	static void cli_process_command(const char *command);
;   21	
;   22	/*
;   23		Zero arguement CLI functions.
;   24	 */
;   25	static void cli_command_info(void);
;   26	static void cli_command_question(void);
;   27	
;   28	/*
;   29		Variable arguement CLI functions.
;   30	
;   31		Multiple arguements encoded as strings, separated by
;   32		whitespace and quotes.
;   33	 */
;   34	static void cli_command_echo(char *args);
;   35	static void cli_command_display(char *args);
;   36	static void cli_command_hex(char *args);
;   37	static void cli_command_set(char *args);
;   38	static void cli_command_switch(char *args);
;   39	static void cli_command_port(char *args);
;   40	static void cli_command_timer(char *args);
;   41	static void cli_command_uart0(char *args);
;   42	
;   43	void init_cli(void)
;   44	{
_init_cli:
.define "_init_cli"
.value _init_cli
.class 2
.type 65
.type 0
.endef
.begfunc "init_cli",44,"_init_cli"
	LINK	#0
;   45		//initialize the hardware
;   46		init_leds();
.line 46
	CALL	_init_leds
;   47		init_uart();
.line 47
	CALL	_init_uart
;   48		init_info();
.line 48
	CALL	_init_info
;   49	
;   50		cli_set_prompt(CLI_PROMPT);
.line 50
	LD	R1,#L__0
	CALL	_cli_set_prompt
;   51	}
.line 51
	UNLINK	
	RET	


;**************************** _init_cli ***************************
;Name                         Addr/Register   Size   Type
;_cli_set_prompt                     IMPORT  -----   function
;_init_info                          IMPORT  -----   function
;_init_uart                          IMPORT  -----   function
;_init_leds                          IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "init_cli",51,"_init_cli"
	SEGMENT ROM_TEXT
L__2:
	DB	"%s"
	DB	0
L__6:
	DB	"%s"
	DB	0
L__12:
	DB	10
	DB	"--Error--, command is too long. Command ignored."
	DB	10,0
L__13:
	DB	"%s"
	DB	0
	SEGMENT CODE
;   52	
;   53	void cli_loop(void)
;   54	{
_cli_loop:
.define "_cli_loop"
.value _cli_loop
.class 2
.type 65
.type 0
.endef
.begfunc "cli_loop",54,"_cli_loop"
.line 54
.define "c"
.class 1
.value -1
.type 12
.type 0
.endef
.define "buffer_pos"
.class 1
.value -5
.type 5
.type 0
.endef
.define "buffer"
.class 1
.value -261
.dim 256
.type 108
.type 0
.endef
	LINK	#0
	SUB	R15,#261
;   55		char buffer[CLI_BUFFER_SIZE];
;   56		char c;
;   57	
;   58		int buffer_pos;
;   59	
;   60		uart_printf("%s", cli_prompt);
.line 60
	PUSH.W	#_cli_prompt
	PUSH.W	#L__2
	CALL	_uart_printf
	ADD	R15,#4
;   61	
;   62		buffer_pos = 0;
.line 62
	CLR	-5(R14)
;   63	
;   64		while(1) {
_2_L_18:
.line 64
;   65			//wait until a character is available
;   66			while((c = uart_getchar()) == 0) { ; }
_2_L_1:
.line 66
	CALL	_uart_getchar
	LD.B	-1(R14),R0
	CPZ.B	-1(R14)
	JP	EQ,_2_L_1
;   67	
;   68			//new line means end of the command
;   69			if(c == '\n') {
.line 69
	LD	R0,#10
	CP.B	-1(R14),R0
	JP	NE,_2_L_14
;   70				//only process a command if something was entered
;   71				if(buffer_pos) {
.line 71
	CPZ	-5(R14)
	JP	EQ,_2_L_4
;   72					buffer[buffer_pos] = '\0';
.line 72
	LD.SW	R0,-3(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	CLR.B	(R0)
;   73					cli_process_command(buffer);
.line 73
	LEA	R1,-261(R14)
	CALL	_cli_process_command
;   74				}
_2_L_4:
.line 74
;   75	
;   76				buffer_pos = 0;
.line 76
	CLR	-5(R14)
;   77				memset(buffer, 0, CLI_BUFFER_SIZE);
.line 77
	LEA	R1,-261(R14)
	LD	R2,#0
	LD	R3,#256
	CALL	_memset
;   78	
;   79				uart_printf("%s", cli_prompt);
.line 79
	PUSH.W	#_cli_prompt
	PUSH.W	#L__6
	CALL	_uart_printf
	ADD	R15,#4
;   80			}
;   81			//there is more to come...
;   82			else if(isgraph(c) || isspace(c)) {
.line 82
	JP	_2_L_17
_2_L_14:
	LD.UB	R1,-1(R14)
	CALL	_isgraph
	CP	R0,#0
	JP	NE,_2_L_11
	LD.UB	R1,-1(R14)
	CALL	_isspace
	CP	R0,#0
	JP	EQ,_2_L_12
_2_L_11:
;   83				buffer[buffer_pos++] = c;
.line 83
	LD	R0,-5(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	LD.SB	R1,-1(R14)
	LD.B	(R0),R1
	INC	-5(R14)
;   84			}
;   85			//
;   86			else if(c == ASCII_DEL) {
.line 86
	JP	_2_L_17
_2_L_12:
	LD	R0,#127
	CP.B	-1(R14),R0
	JP	NE,_2_L_18
;   87				if(buffer_pos) {
.line 87
	CPZ	-5(R14)
	JP	EQ,_2_L_17
;   88					buffer_pos--;
.line 88
	DEC	-5(R14)
;   89					buffer[buffer_pos] = '\0';
.line 89
	LD.SW	R0,-3(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	CLR.B	(R0)
;   90				}
;   91			}
;   92			//ignore for now
;   93			else {
.line 93
;   94				continue;
;   95			}
_2_L_17:
.line 95
;   96	
;   97			//is the command too long?
;   98			if(buffer_pos >= CLI_BUFFER_SIZE) {
.line 98
	LD	R0,#256
	CP	-5(R14),R0
	JP	LT,_2_L_18
;   99				uart_printf("\n--Error--, command is too long. Command ignored.\n");
.line 99
	PUSH.W	#L__12
	CALL	_uart_printf
	ADD	R15,#2
;  100				
;  101				buffer_pos = 0;
.line 101
	CLR	-5(R14)
;  102				memset(buffer, 0, CLI_BUFFER_SIZE);
.line 102
	LEA	R1,-261(R14)
	LD	R2,#0
	LD	R3,#256
	CALL	_memset
;  103	
;  104				uart_printf("%s", cli_prompt);
.line 104
	PUSH.W	#_cli_prompt
	PUSH.W	#L__13
	CALL	_uart_printf
	ADD	R15,#4
;  105			}
;  106		}
.line 106
	JP	_2_L_18
;  107	}
.line 107
	UNLINK	
	RET	


;**************************** _cli_loop ***************************
;Name                         Addr/Register   Size   Type
;_isspace                            IMPORT  -----   function
;_isgraph                            IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_cli_process_command                STATIC  -----   function
;_uart_getchar                       IMPORT  -----   function
;_cli_prompt                         STATIC    256   variable
;_uart_printf                        IMPORT  -----   function
;buffer                             R14-261    256   variable
;buffer_pos                           R14-5      4   variable
;c                                    R14-1      1   variable


; Aggregate Stack Size: -261 (words)


.endfunc "cli_loop",107,"_cli_loop"
;  108	
;  109	int cli_strip_quotes(char **args)
;  110	{
_cli_strip_quotes:
.define "_cli_strip_quotes"
.value _cli_strip_quotes
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_quotes",110,"_cli_strip_quotes"
	LINK	#4
.line 110
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  111		char *c;
;  112	
;  113		c = *args;
.line 113
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  114		if(*c != '"') {
.line 114
	LD.SW	R0,-4(R14)
	LD.UB	R0,(R0)
	CP	R0,#34
	JP	EQ,_3_L_22
;  115			return 1;
.line 115
	LD	R0,#1
	JP	_3_L_25
;  116		}
_3_L_22:
.line 116
;  117		++c;
.line 117
	INC.W	-4(R14)
;  118	
;  119		c = strchr(c, '"');
.line 119
	LD.SW	R1,-4(R14)
	LD	R2,#34
	CALL	_strchr
	LD.W	-4(R14),R0
;  120		if(c == NULL) {
.line 120
	CPZ.W	-4(R14)
	JP	NE,_3_L_24
;  121			return 1;
.line 121
	LD	R0,#1
	JP	_3_L_25
;  122		}
_3_L_24:
.line 122
;  123		*c = '\0';
.line 123
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  124	
;  125		*args = c;
.line 125
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  126	
;  127		return 0;
.line 127
	LD	R0,#0
;  128	}
_3_L_25:
.line 128
	UNLINK	
	RET	


;**************************** _cli_strip_quotes ***************************
;Name                         Addr/Register   Size   Type
;_strchr                             IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_quotes",128,"_cli_strip_quotes"
;  129	
;  130	int cli_strip_word(char **args) 
;  131	{
_cli_strip_word:
.define "_cli_strip_word"
.value _cli_strip_word
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_word",131,"_cli_strip_word"
	LINK	#4
.line 131
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  132		char *c;
;  133	
;  134		c = *args;
.line 134
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  135		while(isalpha(*c)) {
_4_L_26:
.line 135
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isalpha
	CP	R0,#0
	JP	EQ,_4_L_29
;  136			++c;
.line 136
	INC.W	-4(R14)
;  137		}
.line 137
	JP	_4_L_26
_4_L_29:
;  138	
;  139		if(*c == '\0') {
.line 139
	LD.SW	R0,-4(R14)
	CPZ.B	(R0)
	JP	NE,_4_L_30
;  140			return 1;
.line 140
	LD	R0,#1
	JP	_4_L_31
;  141		}
_4_L_30:
.line 141
;  142		*c = '\0';
.line 142
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  143	
;  144		*args = c;
.line 144
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  145	
;  146		return 0;
.line 146
	LD	R0,#0
;  147	}
_4_L_31:
.line 147
	UNLINK	
	RET	


;**************************** _cli_strip_word ***************************
;Name                         Addr/Register   Size   Type
;_isalpha                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_word",147,"_cli_strip_word"
;  148	
;  149	int cli_strip_decimal_number(char **args)
;  150	{
_cli_strip_decimal_number:
.define "_cli_strip_decimal_number"
.value _cli_strip_decimal_number
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_decimal_number",150,"_cli_strip_decimal_number"
	LINK	#4
.line 150
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  151		char *c;
;  152	
;  153		c = *args;
.line 153
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  154		while(isdigit(*c)) {
_5_L_32:
.line 154
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isdigit
	CP	R0,#0
	JP	EQ,_5_L_34
;  155			++c;
.line 155
	INC.W	-4(R14)
;  156		}
.line 156
	JP	_5_L_32
_5_L_34:
;  157		*c = '\0';
.line 157
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  158	
;  159		//is there a number at all
;  160		if(*args == c) {
.line 160
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	CP.W	(R0),R1
	JP	NE,_5_L_36
;  161			return 1;
.line 161
	LD	R0,#1
	JP	_5_L_37
;  162		}
_5_L_36:
.line 162
;  163		*args = c;
.line 163
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  164	
;  165		return 0;
.line 165
	LD	R0,#0
;  166	}
_5_L_37:
.line 166
	UNLINK	
	RET	


;**************************** _cli_strip_decimal_number ***************************
;Name                         Addr/Register   Size   Type
;_isdigit                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_decimal_number",166,"_cli_strip_decimal_number"
;  167	
;  168	void cli_strip_spaces(char **args)
;  169	{
_cli_strip_spaces:
.define "_cli_strip_spaces"
.value _cli_strip_spaces
.class 2
.type 65
.type 0
.endef
.begfunc "cli_strip_spaces",169,"_cli_strip_spaces"
	LINK	#4
.line 169
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  170		char *c;
;  171	
;  172		c = *args;
.line 172
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  173		while(isspace(*c)) {
_6_L_38:
.line 173
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isspace
	CP	R0,#0
	JP	EQ,_6_L_40
;  174			++c;
.line 174
	INC.W	-4(R14)
;  175		}
.line 175
	JP	_6_L_38
_6_L_40:
;  176	
;  177		*args = c;
.line 177
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  178	}
.line 178
	UNLINK	
	RET	


;**************************** _cli_strip_spaces ***************************
;Name                         Addr/Register   Size   Type
;_isspace                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_spaces",178,"_cli_strip_spaces"
;  179	
;  180	void cli_set_prompt(const char *text)
;  181	{
_cli_set_prompt:
.define "_cli_set_prompt"
.value _cli_set_prompt
.class 2
.type 65
.type 0
.endef
.begfunc "cli_set_prompt",181,"_cli_set_prompt"
	LINK	#6
.line 181
	LD.W	-2(R14),R1
.define "text"
.class 9
.value -2
.type 140
.type 0
.endef
.define "prompt_len"
.class 1
.value -6
.type 15
.type 0
.endef
;  182		size_t prompt_len;
;  183		
;  184		prompt_len = strlen(text) + 1;
.line 184
	LD.SW	R1,-2(R14)
	CALL	_strlen
	ADD	R0,#1
	LD	-6(R14),R0
;  185		if(prompt_len >= CLI_BUFFER_SIZE) {
.line 185
	LD	R0,#256
	CP	-6(R14),R0
	JP	C,_7_L_43
;  186			prompt_len = CLI_BUFFER_SIZE;
.line 186
	LD	-6(R14),R0
;  187		}
_7_L_43:
.line 187
;  188		
;  189		memcpy(cli_prompt, text, prompt_len);
.line 189
	LD	R1,#_cli_prompt
	LD.SW	R2,-2(R14)
	LD	R3,-6(R14)
	CALL	_memcpy
;  190		cli_prompt[prompt_len-1] = '\0';
.line 190
	LD	R0,-6(R14)
	ADD	R0,#-1
	LD	R1,#_cli_prompt
	ADD	R0,R1
	CLR.B	(R0)
;  191	}
.line 191
	UNLINK	
	RET	


;**************************** _cli_set_prompt ***************************
;Name                         Addr/Register   Size   Type
;_cli_prompt                         STATIC    256   variable
;_memcpy                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;prompt_len                           R14-6      4   variable
;text                                 R14-2      2   parameter


; Aggregate Stack Size: -6 (words)


.endfunc "cli_set_prompt",191,"_cli_set_prompt"
	SEGMENT ROM_TEXT
L__31:
	DB	"info"
	DB	0
L__33:
	DB	"?"
	DB	0
L__35:
	DB	"echo"
	DB	0
L__37:
	DB	"display"
	DB	0
L__39:
	DB	"set"
	DB	0
L__41:
	DB	"hex"
	DB	0
L__43:
	DB	"switch"
	DB	0
L__45:
	DB	"port"
	DB	0
L__47:
	DB	"timer"
	DB	0
L__49:
	DB	"uart0"
	DB	0
L__51:
	DB	"--Command:%s, not found. Enter \"?\" to see a list of available commands."
	DB	10,0
	SEGMENT CODE
;  192	
;  193	static void cli_process_command(char *command)
;  194	{
_cli_process_command:
.define "_cli_process_command"
.value _cli_process_command
.class 3
.type 65
.type 0
.endef
.begfunc "cli_process_command",194,"_cli_process_command"
	LINK	#4
.line 194
	LD.W	-2(R14),R1
.define "command"
.class 9
.value -2
.type 140
.type 0
.endef
.define "args"
.class 1
.value -4
.type 140
.type 0
.endef
;  195		char *args;
;  196	
;  197		//strip spaces and tabs
;  198		cli_strip_spaces(&command);
.line 198
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  199	
;  200		args = command;
.line 200
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  201		while(isgraph(*args) && *args != '\t') {	//bug with isgraph, returns true on \t and it shouldn't
_8_L_46:
.line 201
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isgraph
	CP	R0,#0
	JP	EQ,_8_L_69
	LD.SW	R0,-4(R14)
	LD.UB	R0,(R0)
	CP	R0,#9
	JP	EQ,_8_L_69
;  202			++args;
.line 202
	INC.W	-4(R14)
;  203		}
.line 203
	JP	_8_L_46
_8_L_69:
;  204	
;  205		if(args != command) {
.line 205
	LD.SW	R0,-2(R14)
	CP.W	-4(R14),R0
	JP	EQ,_8_L_70
;  206			*args = '\0';
.line 206
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  207	
;  208			++args;
.line 208
	INC.W	-4(R14)
;  209			if(strcmp(command, "info") == 0) {
.line 209
	LD.SW	R1,-2(R14)
	LD	R2,#L__31
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_67
;  210				cli_command_info();
.line 210
	CALL	_cli_command_info
;  211			}
;  212			else if(strcmp(command, "?") == 0) {
.line 212
	JP	_8_L_70
_8_L_67:
	LD.SW	R1,-2(R14)
	LD	R2,#L__33
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_65
;  213				cli_command_question();
.line 213
	CALL	_cli_command_question
;  214			}
;  215			else if(strcmp(command, "echo") == 0) {
.line 215
	JP	_8_L_70
_8_L_65:
	LD.SW	R1,-2(R14)
	LD	R2,#L__35
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_63
;  216				cli_command_echo(args);
.line 216
	LD.SW	R1,-4(R14)
	CALL	_cli_command_echo
;  217			}
;  218			else if(strcmp(command, "display") == 0) {
.line 218
	JP	_8_L_70
_8_L_63:
	LD.SW	R1,-2(R14)
	LD	R2,#L__37
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_61
;  219				cli_command_display(args);
.line 219
	LD.SW	R1,-4(R14)
	CALL	_cli_command_display
;  220			}
;  221			else if(strcmp(command, "set") == 0) {
.line 221
	JP	_8_L_70
_8_L_61:
	LD.SW	R1,-2(R14)
	LD	R2,#L__39
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_59
;  222				cli_command_set(args);
.line 222
	LD.SW	R1,-4(R14)
	CALL	_cli_command_set
;  223			}
;  224			else if(strcmp(command, "hex") == 0) {
.line 224
	JP	_8_L_70
_8_L_59:
	LD.SW	R1,-2(R14)
	LD	R2,#L__41
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_57
;  225				cli_command_hex(args);
.line 225
	LD.SW	R1,-4(R14)
	CALL	_cli_command_hex
;  226			}
;  227			else if(strcmp(command, "switch") == 0) {
.line 227
	JP	_8_L_70
_8_L_57:
	LD.SW	R1,-2(R14)
	LD	R2,#L__43
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_55
;  228				cli_command_switch(args);
.line 228
	LD.SW	R1,-4(R14)
	CALL	_cli_command_switch
;  229			}
;  230			else if(strcmp(command, "port") == 0) {
.line 230
	JP	_8_L_70
_8_L_55:
	LD.SW	R1,-2(R14)
	LD	R2,#L__45
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_53
;  231				cli_command_port(args);
.line 231
	LD.SW	R1,-4(R14)
	CALL	_cli_command_port
;  232			}
;  233			else if(strcmp(command, "timer") == 0) {
.line 233
	JP	_8_L_70
_8_L_53:
	LD.SW	R1,-2(R14)
	LD	R2,#L__47
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_51
;  234				cli_command_timer(args);
.line 234
	LD.SW	R1,-4(R14)
	CALL	_cli_command_timer
;  235			}
;  236			else if(strcmp(command, "uart0") == 0) {
.line 236
	JP	_8_L_70
_8_L_51:
	LD.SW	R1,-2(R14)
	LD	R2,#L__49
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_49
;  237				cli_command_uart0(args);
.line 237
	LD.SW	R1,-4(R14)
	CALL	_cli_command_uart0
;  238			}
;  239			else {
.line 239
	JP	_8_L_70
_8_L_49:
;  240				uart_printf("--Command:%s, not found. Enter \"?\" to see a list of available commands.\n", command);
.line 240
	LD.SW	R0,-2(R14)
	PUSH.W	R0
	PUSH.W	#L__51
	CALL	_uart_printf
	ADD	R15,#4
;  241			}
;  242		}
;  243	}
_8_L_70:
.line 243
	UNLINK	
	RET	


;**************************** _cli_process_command ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function
;_cli_command_uart0                  STATIC  -----   function
;_cli_command_timer                  STATIC  -----   function
;_cli_command_port                   STATIC  -----   function
;_cli_command_switch                 STATIC  -----   function
;_cli_command_hex                    STATIC  -----   function
;_cli_command_set                    STATIC  -----   function
;_cli_command_display                STATIC  -----   function
;_cli_command_echo                   STATIC  -----   function
;_cli_command_question               STATIC  -----   function
;_cli_command_info                   STATIC  -----   function
;_strcmp                             IMPORT  -----   function
;_isgraph                            IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;args                                 R14-4      2   variable
;command                              R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_process_command",243,"_cli_process_command"
	SEGMENT ROM_TEXT
L__53:
	DB	10
	DB	"Available Commands:"
	DB	10,10,0
L__54:
	DB	"echo [\"text\"]"
	DB	10,0
L__55:
	DB	" -Echos text back to the serial port."
	DB	10,0
L__56:
	DB	"display [\"text\"]"
	DB	10,0
L__57:
	DB	" -Display text on the LEDs."
	DB	10,0
L__58:
	DB	"set prompt [\"text\"]"
	DB	10,0
L__59:
	DB	" -Set the CLI prompt to text."
	DB	10,0
L__60:
	DB	"hex [decimal number]"
	DB	10,0
L__61:
	DB	" -Display a decimal number in hex on the LEDs."
	DB	10,0
L__62:
	DB	"switch [0-2] [\"text\"]"
	DB	10,0
L__63:
	DB	" -Assigns the text macro to a button."
	DB	10,0
L__64:
	DB	"port [A-K]"
	DB	10,0
L__65:
	DB	" -Display the current state of the port."
	DB	10,0
L__66:
	DB	"timer [0-2]"
	DB	10,0
L__67:
	DB	" -Display the current state of the timer."
	DB	10,0
L__68:
	DB	"uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
L__69:
	DB	" -Set the uart0 settings."
	DB	10,0
L__70:
	DB	"info"
	DB	10,0
L__71:
	DB	" -Displays various system information."
	DB	10,0
L__72:
	DB	"?"
	DB	10,0
L__73:
	DB	" -Displays a menu of CLI commands."
	DB	10,0
	SEGMENT CODE
;  244	
;  245	static void cli_command_question(void)
;  246	{
_cli_command_question:
.define "_cli_command_question"
.value _cli_command_question
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_question",246,"_cli_command_question"
	LINK	#0
;  247		uart_printf("\nAvailable Commands:\n\n");
.line 247
	PUSH.W	#L__53
	CALL	_uart_printf
	ADD	R15,#2
;  248	
;  249		uart_printf("echo [\"text\"]\n");
.line 249
	PUSH.W	#L__54
	CALL	_uart_printf
	ADD	R15,#2
;  250		uart_printf(" -Echos text back to the serial port.\n");
.line 250
	PUSH.W	#L__55
	CALL	_uart_printf
	ADD	R15,#2
;  251	
;  252		uart_printf("display [\"text\"]\n");
.line 252
	PUSH.W	#L__56
	CALL	_uart_printf
	ADD	R15,#2
;  253		uart_printf(" -Display text on the LEDs.\n");
.line 253
	PUSH.W	#L__57
	CALL	_uart_printf
	ADD	R15,#2
;  254	
;  255		uart_printf("set prompt [\"text\"]\n");
.line 255
	PUSH.W	#L__58
	CALL	_uart_printf
	ADD	R15,#2
;  256		uart_printf(" -Set the CLI prompt to text.\n");
.line 256
	PUSH.W	#L__59
	CALL	_uart_printf
	ADD	R15,#2
;  257	
;  258		uart_printf("hex [decimal number]\n");
.line 258
	PUSH.W	#L__60
	CALL	_uart_printf
	ADD	R15,#2
;  259		uart_printf(" -Display a decimal number in hex on the LEDs.\n");
.line 259
	PUSH.W	#L__61
	CALL	_uart_printf
	ADD	R15,#2
;  260	
;  261		uart_printf("switch [0-2] [\"text\"]\n");
.line 261
	PUSH.W	#L__62
	CALL	_uart_printf
	ADD	R15,#2
;  262		uart_printf(" -Assigns the text macro to a button.\n");
.line 262
	PUSH.W	#L__63
	CALL	_uart_printf
	ADD	R15,#2
;  263	
;  264		uart_printf("port [A-K]\n");
.line 264
	PUSH.W	#L__64
	CALL	_uart_printf
	ADD	R15,#2
;  265		uart_printf(" -Display the current state of the port.\n");
.line 265
	PUSH.W	#L__65
	CALL	_uart_printf
	ADD	R15,#2
;  266	
;  267		uart_printf("timer [0-2]\n");
.line 267
	PUSH.W	#L__66
	CALL	_uart_printf
	ADD	R15,#2
;  268		uart_printf(" -Display the current state of the timer.\n");
.line 268
	PUSH.W	#L__67
	CALL	_uart_printf
	ADD	R15,#2
;  269	
;  270		uart_printf("uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 270
	PUSH.W	#L__68
	CALL	_uart_printf
	ADD	R15,#2
;  271		uart_printf(" -Set the uart0 settings.\n");
.line 271
	PUSH.W	#L__69
	CALL	_uart_printf
	ADD	R15,#2
;  272	
;  273		uart_printf("info\n");
.line 273
	PUSH.W	#L__70
	CALL	_uart_printf
	ADD	R15,#2
;  274		uart_printf(" -Displays various system information.\n");
.line 274
	PUSH.W	#L__71
	CALL	_uart_printf
	ADD	R15,#2
;  275	
;  276		uart_printf("?\n");
.line 276
	PUSH.W	#L__72
	CALL	_uart_printf
	ADD	R15,#2
;  277		uart_printf(" -Displays a menu of CLI commands.\n");
.line 277
	PUSH.W	#L__73
	CALL	_uart_printf
	ADD	R15,#2
;  278	}
.line 278
	UNLINK	
	RET	


;**************************** _cli_command_question ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_question",278,"_cli_command_question"
;  279	
;  280	static void cli_command_info(void)
;  281	{
_cli_command_info:
.define "_cli_command_info"
.value _cli_command_info
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_info",281,"_cli_command_info"
	LINK	#0
;  282		info_display();
.line 282
	CALL	_info_display
;  283	}
.line 283
	UNLINK	
	RET	


;**************************** _cli_command_info ***************************
;Name                         Addr/Register   Size   Type
;_info_display                       IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_info",283,"_cli_command_info"
	SEGMENT ROM_TEXT
L__77:
	DB	"Incorrect format, echo [\"text\"]"
	DB	10,0
L__78:
	DB	"%s"
	DB	10,0
	SEGMENT CODE
;  284	
;  285	static void cli_command_echo(char *args)
;  286	{
_cli_command_echo:
.define "_cli_command_echo"
.value _cli_command_echo
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_echo",286,"_cli_command_echo"
	LINK	#4
.line 286
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  287		char *token;
;  288	
;  289		cli_strip_spaces(&args);
.line 289
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  290	
;  291		token = args;
.line 291
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  292		if(cli_strip_quotes(&args)) {
.line 292
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_11_L_74
;  293			uart_printf("Incorrect format, echo [\"text\"]\n");
.line 293
	PUSH.W	#L__77
	CALL	_uart_printf
	ADD	R15,#2
;  294			return;
.line 294
	JP	_11_L_75
;  295		}
_11_L_74:
.line 295
;  296	
;  297		uart_printf("%s\n", ++token);
.line 297
	INC.W	-4(R14)
	LD.SW	R0,-4(R14)
	PUSH.W	R0
	PUSH.W	#L__78
	CALL	_uart_printf
	ADD	R15,#4
;  298	}
_11_L_75:
.line 298
	UNLINK	
	RET	


;**************************** _cli_command_echo ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_echo",298,"_cli_command_echo"
	SEGMENT ROM_TEXT
L__81:
	DB	"Incorrect format, display [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  299	
;  300	static void cli_command_display(char *args)
;  301	{
_cli_command_display:
.define "_cli_command_display"
.value _cli_command_display
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_display",301,"_cli_command_display"
	LINK	#4
.line 301
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  302		char *token;
;  303	
;  304		cli_strip_spaces(&args);
.line 304
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  305	
;  306		token = args;
.line 306
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  307		if(cli_strip_quotes(&args)) {
.line 307
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_12_L_77
;  308			uart_printf("Incorrect format, display [\"text\"]\n");
.line 308
	PUSH.W	#L__81
	CALL	_uart_printf
	ADD	R15,#2
;  309			return;
.line 309
	JP	_12_L_78
;  310		}
_12_L_77:
.line 310
;  311	
;  312		led_display_text(++token);
.line 312
	INC.W	-4(R14)
	LD.SW	R1,-4(R14)
	CALL	_led_display_text
;  313	}
_12_L_78:
.line 313
	UNLINK	
	RET	


;**************************** _cli_command_display ***************************
;Name                         Addr/Register   Size   Type
;_led_display_text                   IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_display",313,"_cli_command_display"
	SEGMENT ROM_TEXT
L__84:
	DB	"1 Incorrect format, hex [decimal number]"
	DB	10,0
	SEGMENT CODE
;  314	
;  315	static void cli_command_hex(char *args)
;  316	{
_cli_command_hex:
.define "_cli_command_hex"
.value _cli_command_hex
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_hex",316,"_cli_command_hex"
	LINK	#8
.line 316
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
.define "value"
.class 1
.value -8
.type 5
.type 0
.endef
;  317		char *token;
;  318		int value;
;  319	
;  320		cli_strip_spaces(&args);
.line 320
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  321	
;  322		token = args;
.line 322
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  323		if(cli_strip_decimal_number(&args)) {
.line 323
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_13_L_80
;  324			uart_printf("1 Incorrect format, hex [decimal number]\n");
.line 324
	PUSH.W	#L__84
	CALL	_uart_printf
	ADD	R15,#2
;  325			return;
.line 325
	JP	_13_L_81
;  326		}
_13_L_80:
.line 326
;  327	
;  328		value = atoi(token);
.line 328
	LD.SW	R1,-4(R14)
	CALL	_atoi
	LD	-8(R14),R0
;  329		led_display_int_hex(value);
.line 329
	LD	R1,-8(R14)
	CALL	_led_display_int_hex
;  330	}
_13_L_81:
.line 330
	UNLINK	
	RET	


;**************************** _cli_command_hex ***************************
;Name                         Addr/Register   Size   Type
;_led_display_int_hex                IMPORT  -----   function
;_atoi                               IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;value                                R14-8      4   variable
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "cli_command_hex",330,"_cli_command_hex"
	SEGMENT ROM_TEXT
L__87:
	DB	"1 Incorrect format, set prompt [\"text\"]"
	DB	10,0
L__88:
	DB	"prompt"
	DB	0
L__91:
	DB	"2 Incorrect format, set prompt [\"text\"]"
	DB	10,0
L__92:
	DB	"3 Incorrect format, set prompt [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  331	
;  332	static void cli_command_set(char *args)
;  333	{
_cli_command_set:
.define "_cli_command_set"
.value _cli_command_set
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_set",333,"_cli_command_set"
	LINK	#4
.line 333
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  334		char *token;
;  335	
;  336		cli_strip_spaces(&args);
.line 336
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  337	
;  338		token = args;
.line 338
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  339		if(cli_strip_word(&args)) {
.line 339
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
	CP	R0,#0
	JP	EQ,_14_L_87
;  340			uart_printf("1 Incorrect format, set prompt [\"text\"]\n");
.line 340
	PUSH.W	#L__87
	CALL	_uart_printf
	ADD	R15,#2
;  341			return;
.line 341
	JP	_14_L_88
;  342		}
_14_L_87:
.line 342
;  343	
;  344		if(strcmp(token, "prompt") == 0) {
.line 344
	LD.SW	R1,-4(R14)
	LD	R2,#L__88
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_14_L_86
;  345			++args;
.line 345
	INC.W	-2(R14)
;  346			cli_strip_spaces(&args);
.line 346
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  347	
;  348			token = args;
.line 348
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  349			if(cli_strip_quotes(&args)) {
.line 349
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_14_L_84
;  350				uart_printf("2 Incorrect format, set prompt [\"text\"]\n");
.line 350
	PUSH.W	#L__91
	CALL	_uart_printf
	ADD	R15,#2
;  351				return;
.line 351
	JP	_14_L_88
;  352			}
_14_L_84:
.line 352
;  353	
;  354			++token;
.line 354
	INC.W	-4(R14)
;  355			cli_set_prompt(token);
.line 355
	LD.SW	R1,-4(R14)
	CALL	_cli_set_prompt
;  356		}
;  357		else {
.line 357
	JP	_14_L_88
_14_L_86:
;  358			uart_printf("3 Incorrect format, set prompt [\"text\"]\n");
.line 358
	PUSH.W	#L__92
	CALL	_uart_printf
	ADD	R15,#2
;  359			return;
;  360		}
;  361	}
_14_L_88:
.line 361
	UNLINK	
	RET	


;**************************** _cli_command_set ***************************
;Name                         Addr/Register   Size   Type
;_cli_set_prompt                     IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_word                     IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_set",361,"_cli_command_set"
	SEGMENT ROM_TEXT
L__95:
	DB	"1 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
L__98:
	DB	"2 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
L__100:
	DB	"3 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  362	
;  363	static void cli_command_switch(char *args)
;  364	{
_cli_command_switch:
.define "_cli_command_switch"
.value _cli_command_switch
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_switch",364,"_cli_command_switch"
	LINK	#8
.line 364
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
.define "value"
.class 1
.value -8
.type 5
.type 0
.endef
;  365		char *token;
;  366		int value;
;  367	
;  368		cli_strip_spaces(&args);
.line 368
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  369	
;  370		token = args;
.line 370
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  371		if(cli_strip_decimal_number(&args)) {
.line 371
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_15_L_90
;  372			uart_printf("1 Incorrect format, switch [n] [\"text\"]\n");
.line 372
	PUSH.W	#L__95
	CALL	_uart_printf
	ADD	R15,#2
;  373			return;
.line 373
	JP	_15_L_96
;  374		}
_15_L_90:
.line 374
;  375		value = atoi(token);
.line 375
	LD.SW	R1,-4(R14)
	CALL	_atoi
	LD	-8(R14),R0
;  376	
;  377		if(value < 0 || value >= MACRO_MAX) {
.line 377
	CPZ	-8(R14)
	JP	LT,_15_L_92
	LD	R0,#3
	CP	-8(R14),R0
	JP	LT,_15_L_93
_15_L_92:
;  378			uart_printf("2 Incorrect format, switch [n] [\"text\"]\n");
.line 378
	PUSH.W	#L__98
	CALL	_uart_printf
	ADD	R15,#2
;  379			return;
.line 379
	JP	_15_L_96
;  380		}
_15_L_93:
.line 380
;  381	
;  382		++args;
.line 382
	INC.W	-2(R14)
;  383		cli_strip_spaces(&args);
.line 383
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  384	
;  385		token = args;
.line 385
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  386		if(cli_strip_quotes(&args)) {
.line 386
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_15_L_95
;  387			uart_printf("3 Incorrect format, switch [n] [\"text\"]\n");
.line 387
	PUSH.W	#L__100
	CALL	_uart_printf
	ADD	R15,#2
;  388			return;
.line 388
	JP	_15_L_96
;  389		}
_15_L_95:
.line 389
;  390	
;  391		macro_set(value, ++token);
.line 391
	INC.W	-4(R14)
	LD	R1,-8(R14)
	LD.SW	R2,-4(R14)
	CALL	_macro_set
;  392	}
_15_L_96:
.line 392
	UNLINK	
	RET	


;**************************** _cli_command_switch ***************************
;Name                         Addr/Register   Size   Type
;_macro_set                          IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_atoi                               IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;value                                R14-8      4   variable
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "cli_command_switch",392,"_cli_command_switch"
	SEGMENT ROM_TEXT
L__103:
	DB	"Incorrect format, port [A-K]"
	DB	10,0
	SEGMENT CODE
;  393	
;  394	static void cli_command_port(char *args)
;  395	{
_cli_command_port:
.define "_cli_command_port"
.value _cli_command_port
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_port",395,"_cli_command_port"
	LINK	#4
.line 395
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  396		char *token;
;  397	
;  398		cli_strip_spaces(&args);
.line 398
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  399	
;  400		token = args;
.line 400
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  401		if(cli_strip_word(&args)) {
.line 401
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
	CP	R0,#0
	JP	EQ,_16_L_98
;  402			uart_printf("Incorrect format, port [A-K]\n");
.line 402
	PUSH.W	#L__103
	CALL	_uart_printf
	ADD	R15,#2
;  403			return;
.line 403
	JP	_16_L_99
;  404		}
_16_L_98:
.line 404
;  405	
;  406		ports_print_config(token);
.line 406
	LD.SW	R1,-4(R14)
	CALL	_ports_print_config
;  407	}
_16_L_99:
.line 407
	UNLINK	
	RET	


;**************************** _cli_command_port ***************************
;Name                         Addr/Register   Size   Type
;_ports_print_config                 IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_word                     IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_port",407,"_cli_command_port"
	SEGMENT ROM_TEXT
L__106:
	DB	"Incorrect format, timer [0-2]"
	DB	10,0
	SEGMENT CODE
;  408	
;  409	static void cli_command_timer(char *args)
;  410	{
_cli_command_timer:
.define "_cli_command_timer"
.value _cli_command_timer
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_timer",410,"_cli_command_timer"
	LINK	#4
.line 410
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  411		char *token;
;  412	
;  413		cli_strip_spaces(&args);
.line 413
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  414	
;  415		token = args;
.line 415
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  416		if(cli_strip_decimal_number(&args)) {
.line 416
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_17_L_101
;  417			uart_printf("Incorrect format, timer [0-2]\n");
.line 417
	PUSH.W	#L__106
	CALL	_uart_printf
	ADD	R15,#2
;  418			return;
.line 418
	JP	_17_L_102
;  419		}
_17_L_101:
.line 419
;  420	
;  421		timers_print_config(token);
.line 421
	LD.SW	R1,-4(R14)
	CALL	_timers_print_config
;  422	}
_17_L_102:
.line 422
	UNLINK	
	RET	


;**************************** _cli_command_timer ***************************
;Name                         Addr/Register   Size   Type
;_timers_print_config                IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_timer",422,"_cli_command_timer"
	SEGMENT ROM_TEXT
L__109:
	DB	"1 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
L__110:
	DB	"speed"
	DB	0
L__113:
	DB	"2 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
L__114:
	DB	"parity"
	DB	0
L__117:
	DB	"3 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
L__118:
	DB	"bits"
	DB	0
L__121:
	DB	"4 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
	SEGMENT CODE
;  423	
;  424	static void cli_command_uart0(char *args)
;  425	{
_cli_command_uart0:
.define "_cli_command_uart0"
.value _cli_command_uart0
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_uart0",425,"_cli_command_uart0"
	LINK	#8
.line 425
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
.define "value"
.class 1
.value -8
.type 5
.type 0
.endef
;  426		char *token;
;  427		int value;
;  428	
;  429		cli_strip_spaces(&args);
.line 429
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  430	
;  431		token = args;
.line 431
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  432		if(cli_strip_word(&args)) {
.line 432
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
	CP	R0,#0
	JP	EQ,_18_L_107
;  433			uart_printf("1 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 433
	PUSH.W	#L__109
	CALL	_uart_printf
	ADD	R15,#2
;  434			return;
.line 434
	JP	_18_L_116
;  435		}
_18_L_107:
.line 435
;  436	
;  437		if(strcmp(token, "speed") == 0) {
.line 437
	LD.SW	R1,-4(R14)
	LD	R2,#L__110
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_18_L_111
;  438			++args;
.line 438
	INC.W	-2(R14)
;  439			
;  440			cli_strip_spaces(&args);		
.line 440
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  441		
;  442			token = args;
.line 442
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  443			if(cli_strip_decimal_number(&args)) {
.line 443
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_18_L_105
;  444				uart_printf("2 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 444
	PUSH.W	#L__113
	CALL	_uart_printf
	ADD	R15,#2
;  445				return;
.line 445
	JP	_18_L_116
;  446			}
_18_L_105:
.line 446
;  447			value = atoi(token);
.line 447
	LD.SW	R1,-4(R14)
	CALL	_atoi
	LD	-8(R14),R0
;  448	
;  449			uart_set_baudrate(value);
.line 449
	LD	R1,-8(R14)
	CALL	_uart_set_baudrate
;  450	
;  451			++args;
.line 451
	INC.W	-2(R14)
;  452			cli_strip_spaces(&args);
.line 452
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  453	
;  454			token = args;
.line 454
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  455			cli_strip_word(&args);
.line 455
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
;  456		}
_18_L_111:
.line 456
;  457		if(strcmp(token, "parity") == 0) {
.line 457
	LD.SW	R1,-4(R14)
	LD	R2,#L__114
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_18_L_115
;  458			++args;
.line 458
	INC.W	-2(R14)
;  459	
;  460			cli_strip_spaces(&args);
.line 460
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  461	
;  462			token = args;
.line 462
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  463			if(cli_strip_word(&args)) {
.line 463
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
	CP	R0,#0
	JP	EQ,_18_L_109
;  464				uart_printf("3 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 464
	PUSH.W	#L__117
	CALL	_uart_printf
	ADD	R15,#2
;  465				return;
.line 465
	JP	_18_L_116
;  466			}
_18_L_109:
.line 466
;  467	
;  468			uart_set_parity(token);
.line 468
	LD.SW	R1,-4(R14)
	CALL	_uart_set_parity
;  469	
;  470			++args;
.line 470
	INC.W	-2(R14)
;  471			cli_strip_spaces(&args);
.line 471
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  472	
;  473			token = args;
.line 473
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  474			cli_strip_word(&args);
.line 474
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
;  475		}
_18_L_115:
.line 475
;  476		if(strcmp(token, "bits") == 0) {
.line 476
	LD.SW	R1,-4(R14)
	LD	R2,#L__118
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_18_L_116
;  477			++args;
.line 477
	INC.W	-2(R14)
;  478	
;  479			cli_strip_spaces(&args);
.line 479
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  480	
;  481			token = args;
.line 481
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  482			if(cli_strip_decimal_number(&args)) {
.line 482
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_18_L_113
;  483				uart_printf("4 Incorrect format, uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 483
	PUSH.W	#L__121
	CALL	_uart_printf
	ADD	R15,#2
;  484				return;
.line 484
	JP	_18_L_116
;  485			}
_18_L_113:
.line 485
;  486	
;  487			uart_set_bits(token);
.line 487
	LD.SW	R1,-4(R14)
	CALL	_uart_set_bits
;  488		}
_18_L_116:
.line 489
	UNLINK	
	RET	


;**************************** _cli_command_uart0 ***************************
;Name                         Addr/Register   Size   Type
;_uart_set_bits                      IMPORT  -----   function
;_uart_set_parity                    IMPORT  -----   function
;_uart_set_baudrate                  IMPORT  -----   function
;_atoi                               IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_word                     IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;value                                R14-8      4   variable
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "cli_command_uart0",489,"_cli_command_uart0"
	XREF _timers_print_config:EROM
	XREF _isspace:EROM
	XREF _isgraph:EROM
	XREF _isdigit:EROM
	XREF _isalpha:EROM
	XREF _memset:EROM
	XREF _memcpy:EROM
	XREF _strlen:EROM
	XREF _strchr:EROM
	XREF _strcmp:EROM
	XREF _atoi:EROM
	XREF _ports_print_config:EROM
	XREF _macro_set:EROM
	XREF _info_display:EROM
	XREF _init_info:EROM
	XREF _uart_set_bits:EROM
	XREF _uart_set_parity:EROM
	XREF _uart_set_baudrate:EROM
	XREF _uart_printf:EROM
	XREF _uart_getchar:EROM
	XREF _init_uart:EROM
	XREF _led_display_int_hex:EROM
	XREF _led_display_text:EROM
	XREF _init_leds:EROM
	XDEF _cli_set_prompt
	XDEF _cli_strip_spaces
	XDEF _cli_strip_decimal_number
	XDEF _cli_strip_word
	XDEF _cli_strip_quotes
	XDEF _cli_loop
	XDEF _init_cli
	END
