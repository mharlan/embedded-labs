; ZiLOG ZNEO ANSI C Compiler Release 1.11
; -nolocalcse -optsize -model=S -nomodsect -noregvar
; -reduceopt -debug -peephole -const=ROM -alias -fastcall
	FILE	"..\CLI.C"
.debug "C"
	SEGMENT NEAR_BSS
_cli_prompt:
	DS	256
.define "cli_prompt"
.alias "_cli_prompt"
.class 147
.value _cli_prompt
.dim 256
.type 108
.type 0
.endef
	SEGMENT CODE
.begrec "NONAME0",8
.define "quot"
.value 0
.class 8
.type 5
.type 0
.endef
.define "rem"
.value 4
.class 8
.type 5
.type 0
.endef
.endrec "NONAME0"
.begrec "NONAME1",8
.define "quot"
.value 0
.class 8
.type 5
.type 0
.endef
.define "rem"
.value 4
.class 8
.type 5
.type 0
.endef
.endrec "NONAME1"
	SEGMENT ROM_TEXT
L__0:
	DB	"> "
	DB	0
;    1	#include "cli.h"
;    2	#include "LED.h"
;    3	#include "uart.h"
;    4	#include "info.h"
;    5	#include "macro.h"
;    6	
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <ctype.h>
;   10	
;   11	#define CLI_PROMPT      "> "
;   12	#define CLI_BUFFER_SIZE 256
;   13	
;   14	#define ASCII_DEL 0x7F
;   15	
;   16	static char cli_prompt[CLI_BUFFER_SIZE];
	SEGMENT CODE
;   17	
;   18	static void cli_process_command(const char *command);
;   19	
;   20	/*
;   21		Zero arguement CLI functions.
;   22	 */
;   23	static void cli_command_info(void);
;   24	static void cli_command_question(void);
;   25	
;   26	/*
;   27		Variable arguement CLI functions.
;   28	
;   29		Multiple arguements encoded as strings, separated by
;   30		whitespace and quotes.
;   31	 */
;   32	static void cli_command_echo(char *args);
;   33	static void cli_command_display(char *args);
;   34	static void cli_command_hex(char *args);
;   35	static void cli_command_set(char *args);
;   36	static void cli_command_switch(char *args);
;   37	static void cli_command_port(char *args);
;   38	static void cli_command_timer(char *args);
;   39	static void cli_command_uart0(char *args);
;   40	
;   41	void init_cli(void)
;   42	{
_init_cli:
.define "_init_cli"
.value _init_cli
.class 2
.type 65
.type 0
.endef
.begfunc "init_cli",42,"_init_cli"
	LINK	#0
;   43		//initialize the hardware
;   44		init_leds();
.line 44
	CALL	_init_leds
;   45		init_uart();
.line 45
	CALL	_init_uart
;   46		init_info();
.line 46
	CALL	_init_info
;   47	
;   48		strcpy(cli_prompt, CLI_PROMPT);
.line 48
	LD	R1,#_cli_prompt
	LD	R2,#L__0
	CALL	_strcpy
;   49	}
.line 49
	UNLINK	
	RET	


;**************************** _init_cli ***************************
;Name                         Addr/Register   Size   Type
;_cli_prompt                         STATIC    256   variable
;_strcpy                             IMPORT  -----   function
;_init_info                          IMPORT  -----   function
;_init_uart                          IMPORT  -----   function
;_init_leds                          IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "init_cli",49,"_init_cli"
	SEGMENT ROM_TEXT
L__2:
	DB	"%s"
	DB	0
L__6:
	DB	"%s"
	DB	0
L__12:
	DB	10
	DB	"--Error--, command is too long. Command ignored."
	DB	10,0
L__13:
	DB	"%s"
	DB	0
	SEGMENT CODE
;   50	
;   51	void cli_loop(void)
;   52	{
_cli_loop:
.define "_cli_loop"
.value _cli_loop
.class 2
.type 65
.type 0
.endef
.begfunc "cli_loop",52,"_cli_loop"
.line 52
.define "c"
.class 1
.value -1
.type 12
.type 0
.endef
.define "buffer_pos"
.class 1
.value -5
.type 5
.type 0
.endef
.define "buffer"
.class 1
.value -261
.dim 256
.type 108
.type 0
.endef
	LINK	#0
	SUB	R15,#261
;   53		char buffer[CLI_BUFFER_SIZE];
;   54		char c;
;   55	
;   56		int buffer_pos;
;   57	
;   58		uart_printf("%s", cli_prompt);
.line 58
	PUSH.W	#_cli_prompt
	PUSH.W	#L__2
	CALL	_uart_printf
	ADD	R15,#4
;   59	
;   60		buffer_pos = 0;
.line 60
	CLR	-5(R14)
;   61	
;   62		while(1) {
_2_L_18:
.line 62
;   63			//wait until a character is available
;   64			while((c = uart_getchar()) == 0) { ; }
_2_L_1:
.line 64
	CALL	_uart_getchar
	LD.B	-1(R14),R0
	CPZ.B	-1(R14)
	JP	EQ,_2_L_1
;   65	
;   66			//new line means end of the command
;   67			if(c == '\n') {
.line 67
	LD	R0,#10
	CP.B	-1(R14),R0
	JP	NE,_2_L_14
;   68				//only process a command if something was entered
;   69				if(buffer_pos) {
.line 69
	CPZ	-5(R14)
	JP	EQ,_2_L_4
;   70					buffer[buffer_pos] = '\0';
.line 70
	LD.SW	R0,-3(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	CLR.B	(R0)
;   71					cli_process_command(buffer);
.line 71
	LEA	R1,-261(R14)
	CALL	_cli_process_command
;   72				}
_2_L_4:
.line 72
;   73	
;   74				buffer_pos = 0;
.line 74
	CLR	-5(R14)
;   75				memset(buffer, 0, CLI_BUFFER_SIZE);
.line 75
	LEA	R1,-261(R14)
	LD	R2,#0
	LD	R3,#256
	CALL	_memset
;   76	
;   77				uart_printf("%s", cli_prompt);
.line 77
	PUSH.W	#_cli_prompt
	PUSH.W	#L__6
	CALL	_uart_printf
	ADD	R15,#4
;   78			}
;   79			//there is more to come...
;   80			else if(isgraph(c) || isspace(c)) {
.line 80
	JP	_2_L_17
_2_L_14:
	LD.UB	R1,-1(R14)
	CALL	_isgraph
	CP	R0,#0
	JP	NE,_2_L_11
	LD.UB	R1,-1(R14)
	CALL	_isspace
	CP	R0,#0
	JP	EQ,_2_L_12
_2_L_11:
;   81				buffer[buffer_pos++] = c;
.line 81
	LD	R0,-5(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	LD.SB	R1,-1(R14)
	LD.B	(R0),R1
	INC	-5(R14)
;   82			}
;   83			//
;   84			else if(c == ASCII_DEL) {
.line 84
	JP	_2_L_17
_2_L_12:
	LD	R0,#127
	CP.B	-1(R14),R0
	JP	NE,_2_L_18
;   85				if(buffer_pos) {
.line 85
	CPZ	-5(R14)
	JP	EQ,_2_L_17
;   86					buffer_pos--;
.line 86
	DEC	-5(R14)
;   87					buffer[buffer_pos] = '\0';
.line 87
	LD.SW	R0,-3(R14)
	LEA	R1,-261(R14)
	ADD	R0,R1
	CLR.B	(R0)
;   88				}
;   89			}
;   90			//ignore for now
;   91			else {
.line 91
;   92				continue;
;   93			}
_2_L_17:
.line 93
;   94	
;   95			//is the command too long?
;   96			if(buffer_pos >= CLI_BUFFER_SIZE) {
.line 96
	LD	R0,#256
	CP	-5(R14),R0
	JP	LT,_2_L_18
;   97				uart_printf("\n--Error--, command is too long. Command ignored.\n");
.line 97
	PUSH.W	#L__12
	CALL	_uart_printf
	ADD	R15,#2
;   98				
;   99				buffer_pos = 0;
.line 99
	CLR	-5(R14)
;  100				memset(buffer, 0, CLI_BUFFER_SIZE);
.line 100
	LEA	R1,-261(R14)
	LD	R2,#0
	LD	R3,#256
	CALL	_memset
;  101	
;  102				uart_printf("%s", cli_prompt);
.line 102
	PUSH.W	#_cli_prompt
	PUSH.W	#L__13
	CALL	_uart_printf
	ADD	R15,#4
;  103			}
;  104		}
.line 104
	JP	_2_L_18
;  105	}
.line 105
	UNLINK	
	RET	


;**************************** _cli_loop ***************************
;Name                         Addr/Register   Size   Type
;_isspace                            IMPORT  -----   function
;_isgraph                            IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_cli_process_command                STATIC  -----   function
;_uart_getchar                       IMPORT  -----   function
;_cli_prompt                         STATIC    256   variable
;_uart_printf                        IMPORT  -----   function
;buffer                             R14-261    256   variable
;buffer_pos                           R14-5      4   variable
;c                                    R14-1      1   variable


; Aggregate Stack Size: -261 (words)


.endfunc "cli_loop",105,"_cli_loop"
;  106	
;  107	int cli_strip_quotes(char **args)
;  108	{
_cli_strip_quotes:
.define "_cli_strip_quotes"
.value _cli_strip_quotes
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_quotes",108,"_cli_strip_quotes"
	LINK	#4
.line 108
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  109		char *c;
;  110	
;  111		c = *args;
.line 111
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  112		if(*c != '"') {
.line 112
	LD.SW	R0,-4(R14)
	LD.UB	R0,(R0)
	CP	R0,#34
	JP	EQ,_3_L_22
;  113			return 1;
.line 113
	LD	R0,#1
	JP	_3_L_25
;  114		}
_3_L_22:
.line 114
;  115		++c;
.line 115
	INC.W	-4(R14)
;  116	
;  117		c = strchr(c, '"');
.line 117
	LD.SW	R1,-4(R14)
	LD	R2,#34
	CALL	_strchr
	LD.W	-4(R14),R0
;  118		if(c == NULL) {
.line 118
	CPZ.W	-4(R14)
	JP	NE,_3_L_24
;  119			return 1;
.line 119
	LD	R0,#1
	JP	_3_L_25
;  120		}
_3_L_24:
.line 120
;  121		*c = '\0';
.line 121
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  122	
;  123		*args = c;
.line 123
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  124	
;  125		return 0;
.line 125
	LD	R0,#0
;  126	}
_3_L_25:
.line 126
	UNLINK	
	RET	


;**************************** _cli_strip_quotes ***************************
;Name                         Addr/Register   Size   Type
;_strchr                             IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_quotes",126,"_cli_strip_quotes"
;  127	
;  128	int cli_strip_word(char **args) 
;  129	{
_cli_strip_word:
.define "_cli_strip_word"
.value _cli_strip_word
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_word",129,"_cli_strip_word"
	LINK	#4
.line 129
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  130		char *c;
;  131	
;  132		c = *args;
.line 132
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  133		while(isalpha(*c)) {
_4_L_26:
.line 133
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isalpha
	CP	R0,#0
	JP	EQ,_4_L_29
;  134			++c;
.line 134
	INC.W	-4(R14)
;  135		}
.line 135
	JP	_4_L_26
_4_L_29:
;  136	
;  137		if(*c == '\0') {
.line 137
	LD.SW	R0,-4(R14)
	CPZ.B	(R0)
	JP	NE,_4_L_30
;  138			return 1;
.line 138
	LD	R0,#1
	JP	_4_L_31
;  139		}
_4_L_30:
.line 139
;  140		*c = '\0';
.line 140
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  141	
;  142		*args = c;
.line 142
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  143	
;  144		return 0;
.line 144
	LD	R0,#0
;  145	}
_4_L_31:
.line 145
	UNLINK	
	RET	


;**************************** _cli_strip_word ***************************
;Name                         Addr/Register   Size   Type
;_isalpha                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_word",145,"_cli_strip_word"
;  146	
;  147	int cli_strip_decimal_number(char **args)
;  148	{
_cli_strip_decimal_number:
.define "_cli_strip_decimal_number"
.value _cli_strip_decimal_number
.class 2
.type 69
.type 0
.endef
.begfunc "cli_strip_decimal_number",148,"_cli_strip_decimal_number"
	LINK	#4
.line 148
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  149		char *c;
;  150	
;  151		c = *args;
.line 151
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  152		while(isdigit(*c)) {
_5_L_32:
.line 152
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isdigit
	CP	R0,#0
	JP	EQ,_5_L_34
;  153			++c;
.line 153
	INC.W	-4(R14)
;  154		}
.line 154
	JP	_5_L_32
_5_L_34:
;  155		*c = '\0';
.line 155
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  156	
;  157		//is there a number at all
;  158		if(*args == c) {
.line 158
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	CP.W	(R0),R1
	JP	NE,_5_L_36
;  159			return 1;
.line 159
	LD	R0,#1
	JP	_5_L_37
;  160		}
_5_L_36:
.line 160
;  161		*args = c;
.line 161
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  162	
;  163		return 0;
.line 163
	LD	R0,#0
;  164	}
_5_L_37:
.line 164
	UNLINK	
	RET	


;**************************** _cli_strip_decimal_number ***************************
;Name                         Addr/Register   Size   Type
;_isdigit                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_decimal_number",164,"_cli_strip_decimal_number"
;  165	
;  166	void cli_strip_spaces(char **args)
;  167	{
_cli_strip_spaces:
.define "_cli_strip_spaces"
.value _cli_strip_spaces
.class 2
.type 65
.type 0
.endef
.begfunc "cli_strip_spaces",167,"_cli_strip_spaces"
	LINK	#4
.line 167
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 1164
.type 0
.endef
.define "c"
.class 1
.value -4
.type 140
.type 0
.endef
;  168		char *c;
;  169	
;  170		c = *args;
.line 170
	LD.SW	R0,-2(R14)
	LD.SW	R0,(R0)
	LD.W	-4(R14),R0
;  171		while(isspace(*c)) {
_6_L_38:
.line 171
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isspace
	CP	R0,#0
	JP	EQ,_6_L_40
;  172			++c;
.line 172
	INC.W	-4(R14)
;  173		}
.line 173
	JP	_6_L_38
_6_L_40:
;  174	
;  175		*args = c;
.line 175
	LD.SW	R0,-2(R14)
	LD.SW	R1,-4(R14)
	LD.W	(R0),R1
;  176	}
.line 176
	UNLINK	
	RET	


;**************************** _cli_strip_spaces ***************************
;Name                         Addr/Register   Size   Type
;_isspace                            IMPORT  -----   function
;c                                    R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_strip_spaces",176,"_cli_strip_spaces"
;  177	
;  178	void cli_set_prompt(const char *text)
;  179	{
_cli_set_prompt:
.define "_cli_set_prompt"
.value _cli_set_prompt
.class 2
.type 65
.type 0
.endef
.begfunc "cli_set_prompt",179,"_cli_set_prompt"
	LINK	#6
.line 179
	LD.W	-2(R14),R1
.define "text"
.class 9
.value -2
.type 140
.type 0
.endef
.define "prompt_len"
.class 1
.value -6
.type 15
.type 0
.endef
;  180		size_t prompt_len;
;  181	
;  182		prompt_len = strlen(text) + 1;
.line 182
	LD.SW	R1,-2(R14)
	CALL	_strlen
	ADD	R0,#1
	LD	-6(R14),R0
;  183		if(prompt_len >= CLI_BUFFER_SIZE) {
.line 183
	LD	R0,#256
	CP	-6(R14),R0
	JP	C,_7_L_43
;  184			prompt_len = CLI_BUFFER_SIZE;
.line 184
	LD	-6(R14),R0
;  185		}
_7_L_43:
.line 185
;  186	
;  187		memcpy(cli_prompt, text, prompt_len);
.line 187
	LD	R1,#_cli_prompt
	LD.SW	R2,-2(R14)
	LD	R3,-6(R14)
	CALL	_memcpy
;  188		cli_prompt[prompt_len-1] = '\0';
.line 188
	LD	R0,-6(R14)
	ADD	R0,#-1
	LD	R1,#_cli_prompt
	ADD	R0,R1
	CLR.B	(R0)
;  189	}
.line 189
	UNLINK	
	RET	


;**************************** _cli_set_prompt ***************************
;Name                         Addr/Register   Size   Type
;_cli_prompt                         STATIC    256   variable
;_memcpy                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;prompt_len                           R14-6      4   variable
;text                                 R14-2      2   parameter


; Aggregate Stack Size: -6 (words)


.endfunc "cli_set_prompt",189,"_cli_set_prompt"
	SEGMENT ROM_TEXT
L__31:
	DB	"info"
	DB	0
L__33:
	DB	"?"
	DB	0
L__35:
	DB	"echo"
	DB	0
L__37:
	DB	"display"
	DB	0
L__39:
	DB	"set"
	DB	0
L__41:
	DB	"hex"
	DB	0
L__43:
	DB	"switch"
	DB	0
L__45:
	DB	"port"
	DB	0
L__47:
	DB	"timer"
	DB	0
L__49:
	DB	"uart0"
	DB	0
L__51:
	DB	"--Command:%s, not found. Enter \"?\" to see a list of available commands."
	DB	10,0
	SEGMENT CODE
;  190	
;  191	static void cli_process_command(char *command)
;  192	{
_cli_process_command:
.define "_cli_process_command"
.value _cli_process_command
.class 3
.type 65
.type 0
.endef
.begfunc "cli_process_command",192,"_cli_process_command"
	LINK	#4
.line 192
	LD.W	-2(R14),R1
.define "command"
.class 9
.value -2
.type 140
.type 0
.endef
.define "args"
.class 1
.value -4
.type 140
.type 0
.endef
;  193		char *args;
;  194	
;  195		//strip spaces and tabs
;  196		cli_strip_spaces(&command);
.line 196
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  197	
;  198		args = command;
.line 198
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  199		while(isgraph(*args) && *args != '\t') {	//bug with isgraph, returns true on \t and it shouldn't
_8_L_46:
.line 199
	LD.SW	R0,-4(R14)
	LD.UB	R1,(R0)
	CALL	_isgraph
	CP	R0,#0
	JP	EQ,_8_L_69
	LD.SW	R0,-4(R14)
	LD.UB	R0,(R0)
	CP	R0,#9
	JP	EQ,_8_L_69
;  200			++args;
.line 200
	INC.W	-4(R14)
;  201		}
.line 201
	JP	_8_L_46
_8_L_69:
;  202	
;  203		if(args != command) {
.line 203
	LD.SW	R0,-2(R14)
	CP.W	-4(R14),R0
	JP	EQ,_8_L_70
;  204			*args = '\0';
.line 204
	LD.SW	R0,-4(R14)
	CLR.B	(R0)
;  205	
;  206			++args;
.line 206
	INC.W	-4(R14)
;  207			if(strcmp(command, "info") == 0) {
.line 207
	LD.SW	R1,-2(R14)
	LD	R2,#L__31
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_67
;  208				cli_command_info();
.line 208
	CALL	_cli_command_info
;  209			}
;  210			else if(strcmp(command, "?") == 0) {
.line 210
	JP	_8_L_70
_8_L_67:
	LD.SW	R1,-2(R14)
	LD	R2,#L__33
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_65
;  211				cli_command_question();
.line 211
	CALL	_cli_command_question
;  212			}
;  213			else if(strcmp(command, "echo") == 0) {
.line 213
	JP	_8_L_70
_8_L_65:
	LD.SW	R1,-2(R14)
	LD	R2,#L__35
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_63
;  214				cli_command_echo(args);
.line 214
	LD.SW	R1,-4(R14)
	CALL	_cli_command_echo
;  215			}
;  216			else if(strcmp(command, "display") == 0) {
.line 216
	JP	_8_L_70
_8_L_63:
	LD.SW	R1,-2(R14)
	LD	R2,#L__37
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_61
;  217				cli_command_display(args);
.line 217
	LD.SW	R1,-4(R14)
	CALL	_cli_command_display
;  218			}
;  219			else if(strcmp(command, "set") == 0) {
.line 219
	JP	_8_L_70
_8_L_61:
	LD.SW	R1,-2(R14)
	LD	R2,#L__39
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_59
;  220				cli_command_set(args);
.line 220
	LD.SW	R1,-4(R14)
	CALL	_cli_command_set
;  221			}
;  222			else if(strcmp(command, "hex") == 0) {
.line 222
	JP	_8_L_70
_8_L_59:
	LD.SW	R1,-2(R14)
	LD	R2,#L__41
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_57
;  223				cli_command_hex(args);
.line 223
	LD.SW	R1,-4(R14)
	CALL	_cli_command_hex
;  224			}
;  225			else if(strcmp(command, "switch") == 0) {
.line 225
	JP	_8_L_70
_8_L_57:
	LD.SW	R1,-2(R14)
	LD	R2,#L__43
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_55
;  226				cli_command_switch(args);
.line 226
	LD.SW	R1,-4(R14)
	CALL	_cli_command_switch
;  227			}
;  228			else if(strcmp(command, "port") == 0) {
.line 228
	JP	_8_L_70
_8_L_55:
	LD.SW	R1,-2(R14)
	LD	R2,#L__45
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_53
;  229				cli_command_port(args);
.line 229
	LD.SW	R1,-4(R14)
	CALL	_cli_command_port
;  230			}
;  231			else if(strcmp(command, "timer") == 0) {
.line 231
	JP	_8_L_70
_8_L_53:
	LD.SW	R1,-2(R14)
	LD	R2,#L__47
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_51
;  232				cli_command_timer(args);
.line 232
	LD.SW	R1,-4(R14)
	CALL	_cli_command_timer
;  233			}
;  234			else if(strcmp(command, "uart0") == 0) {
.line 234
	JP	_8_L_70
_8_L_51:
	LD.SW	R1,-2(R14)
	LD	R2,#L__49
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_8_L_49
;  235				cli_command_uart0(args);
.line 235
	LD.SW	R1,-4(R14)
	CALL	_cli_command_uart0
;  236			}
;  237			else {
.line 237
	JP	_8_L_70
_8_L_49:
;  238				uart_printf("--Command:%s, not found. Enter \"?\" to see a list of available commands.\n", command);
.line 238
	LD.SW	R0,-2(R14)
	PUSH.W	R0
	PUSH.W	#L__51
	CALL	_uart_printf
	ADD	R15,#4
;  239			}
;  240		}
;  241	}
_8_L_70:
.line 241
	UNLINK	
	RET	


;**************************** _cli_process_command ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function
;_cli_command_uart0                  STATIC  -----   function
;_cli_command_timer                  STATIC  -----   function
;_cli_command_port                   STATIC  -----   function
;_cli_command_switch                 STATIC  -----   function
;_cli_command_hex                    STATIC  -----   function
;_cli_command_set                    STATIC  -----   function
;_cli_command_display                STATIC  -----   function
;_cli_command_echo                   STATIC  -----   function
;_cli_command_question               STATIC  -----   function
;_cli_command_info                   STATIC  -----   function
;_strcmp                             IMPORT  -----   function
;_isgraph                            IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;args                                 R14-4      2   variable
;command                              R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_process_command",241,"_cli_process_command"
	SEGMENT ROM_TEXT
L__53:
	DB	10
	DB	"Available Commands:"
	DB	10,10,0
L__54:
	DB	"echo [\"text\"]"
	DB	10,0
L__55:
	DB	" -Echos text back to the serial port."
	DB	10,0
L__56:
	DB	"display [\"text\"]"
	DB	10,0
L__57:
	DB	" -Display text on the LEDs."
	DB	10,0
L__58:
	DB	"set prompt [\"text\"]"
	DB	10,0
L__59:
	DB	" -Set the CLI prompt to text."
	DB	10,0
L__60:
	DB	"hex [decimal number]"
	DB	10,0
L__61:
	DB	" -Display a decimal number in hex on the LEDs."
	DB	10,0
L__62:
	DB	"switch [0-2] [\"text\"]"
	DB	10,0
L__63:
	DB	" -Assigns the text macro to a button."
	DB	10,0
L__64:
	DB	"port [A-K]"
	DB	10,0
L__65:
	DB	" -Display the current state of the port."
	DB	10,0
L__66:
	DB	"timer [0-2]"
	DB	10,0
L__67:
	DB	" -Display the current state of the timer."
	DB	10,0
L__68:
	DB	"uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]"
	DB	10,0
L__69:
	DB	" -Set the uart0 settings."
	DB	10,0
L__70:
	DB	"info"
	DB	10,0
L__71:
	DB	" -Displays various system information."
	DB	10,0
L__72:
	DB	"?"
	DB	10,0
L__73:
	DB	" -Displays a menu of CLI commands."
	DB	10,0
	SEGMENT CODE
;  242	
;  243	static void cli_command_question(void)
;  244	{
_cli_command_question:
.define "_cli_command_question"
.value _cli_command_question
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_question",244,"_cli_command_question"
	LINK	#0
;  245		uart_printf("\nAvailable Commands:\n\n");
.line 245
	PUSH.W	#L__53
	CALL	_uart_printf
	ADD	R15,#2
;  246	
;  247		uart_printf("echo [\"text\"]\n");
.line 247
	PUSH.W	#L__54
	CALL	_uart_printf
	ADD	R15,#2
;  248		uart_printf(" -Echos text back to the serial port.\n");
.line 248
	PUSH.W	#L__55
	CALL	_uart_printf
	ADD	R15,#2
;  249	
;  250		uart_printf("display [\"text\"]\n");
.line 250
	PUSH.W	#L__56
	CALL	_uart_printf
	ADD	R15,#2
;  251		uart_printf(" -Display text on the LEDs.\n");
.line 251
	PUSH.W	#L__57
	CALL	_uart_printf
	ADD	R15,#2
;  252	
;  253		uart_printf("set prompt [\"text\"]\n");
.line 253
	PUSH.W	#L__58
	CALL	_uart_printf
	ADD	R15,#2
;  254		uart_printf(" -Set the CLI prompt to text.\n");
.line 254
	PUSH.W	#L__59
	CALL	_uart_printf
	ADD	R15,#2
;  255	
;  256		uart_printf("hex [decimal number]\n");
.line 256
	PUSH.W	#L__60
	CALL	_uart_printf
	ADD	R15,#2
;  257		uart_printf(" -Display a decimal number in hex on the LEDs.\n");
.line 257
	PUSH.W	#L__61
	CALL	_uart_printf
	ADD	R15,#2
;  258	
;  259		uart_printf("switch [0-2] [\"text\"]\n");
.line 259
	PUSH.W	#L__62
	CALL	_uart_printf
	ADD	R15,#2
;  260		uart_printf(" -Assigns the text macro to a button.\n");
.line 260
	PUSH.W	#L__63
	CALL	_uart_printf
	ADD	R15,#2
;  261	
;  262		uart_printf("port [A-K]\n");
.line 262
	PUSH.W	#L__64
	CALL	_uart_printf
	ADD	R15,#2
;  263		uart_printf(" -Display the current state of the port.\n");
.line 263
	PUSH.W	#L__65
	CALL	_uart_printf
	ADD	R15,#2
;  264	
;  265		uart_printf("timer [0-2]\n");
.line 265
	PUSH.W	#L__66
	CALL	_uart_printf
	ADD	R15,#2
;  266		uart_printf(" -Display the current state of the timer.\n");
.line 266
	PUSH.W	#L__67
	CALL	_uart_printf
	ADD	R15,#2
;  267	
;  268		uart_printf("uart0 [speed [baudrate]] [parity [even|odd|none]] [bits [7|8]]\n");
.line 268
	PUSH.W	#L__68
	CALL	_uart_printf
	ADD	R15,#2
;  269		uart_printf(" -Set the uart0 settings.\n");
.line 269
	PUSH.W	#L__69
	CALL	_uart_printf
	ADD	R15,#2
;  270	
;  271		uart_printf("info\n");
.line 271
	PUSH.W	#L__70
	CALL	_uart_printf
	ADD	R15,#2
;  272		uart_printf(" -Displays various system information.\n");
.line 272
	PUSH.W	#L__71
	CALL	_uart_printf
	ADD	R15,#2
;  273	
;  274		uart_printf("?\n");
.line 274
	PUSH.W	#L__72
	CALL	_uart_printf
	ADD	R15,#2
;  275		uart_printf(" -Displays a menu of CLI commands.\n");
.line 275
	PUSH.W	#L__73
	CALL	_uart_printf
	ADD	R15,#2
;  276	}
.line 276
	UNLINK	
	RET	


;**************************** _cli_command_question ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_question",276,"_cli_command_question"
;  277	
;  278	static void cli_command_info(void)
;  279	{
_cli_command_info:
.define "_cli_command_info"
.value _cli_command_info
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_info",279,"_cli_command_info"
	LINK	#0
;  280		info_display();
.line 280
	CALL	_info_display
;  281	}
.line 281
	UNLINK	
	RET	


;**************************** _cli_command_info ***************************
;Name                         Addr/Register   Size   Type
;_info_display                       IMPORT  -----   function


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_info",281,"_cli_command_info"
	SEGMENT ROM_TEXT
L__77:
	DB	"Incorrect format, echo [\"text\"]"
	DB	10,0
L__78:
	DB	"%s"
	DB	10,0
	SEGMENT CODE
;  282	
;  283	static void cli_command_echo(char *args)
;  284	{
_cli_command_echo:
.define "_cli_command_echo"
.value _cli_command_echo
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_echo",284,"_cli_command_echo"
	LINK	#4
.line 284
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  285		char *token;
;  286	
;  287		cli_strip_spaces(&args);
.line 287
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  288	
;  289		token = args;
.line 289
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  290		if(cli_strip_quotes(&args)) {
.line 290
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_11_L_74
;  291			uart_printf("Incorrect format, echo [\"text\"]\n");
.line 291
	PUSH.W	#L__77
	CALL	_uart_printf
	ADD	R15,#2
;  292			return;
.line 292
	JP	_11_L_75
;  293		}
_11_L_74:
.line 293
;  294	
;  295		uart_printf("%s\n", ++token);
.line 295
	INC.W	-4(R14)
	LD.SW	R0,-4(R14)
	PUSH.W	R0
	PUSH.W	#L__78
	CALL	_uart_printf
	ADD	R15,#4
;  296	}
_11_L_75:
.line 296
	UNLINK	
	RET	


;**************************** _cli_command_echo ***************************
;Name                         Addr/Register   Size   Type
;_uart_printf                        IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_echo",296,"_cli_command_echo"
	SEGMENT ROM_TEXT
L__81:
	DB	"Incorrect format, display [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  297	
;  298	static void cli_command_display(char *args)
;  299	{
_cli_command_display:
.define "_cli_command_display"
.value _cli_command_display
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_display",299,"_cli_command_display"
	LINK	#4
.line 299
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  300		char *token;
;  301	
;  302		cli_strip_spaces(&args);
.line 302
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  303	
;  304		token = args;
.line 304
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  305		if(cli_strip_quotes(&args)) {
.line 305
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_12_L_77
;  306			uart_printf("Incorrect format, display [\"text\"]\n");
.line 306
	PUSH.W	#L__81
	CALL	_uart_printf
	ADD	R15,#2
;  307			return;
.line 307
	JP	_12_L_78
;  308		}
_12_L_77:
.line 308
;  309	
;  310		led_display_text(++token);
.line 310
	INC.W	-4(R14)
	LD.SW	R1,-4(R14)
	CALL	_led_display_text
;  311	}
_12_L_78:
.line 311
	UNLINK	
	RET	


;**************************** _cli_command_display ***************************
;Name                         Addr/Register   Size   Type
;_led_display_text                   IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_display",311,"_cli_command_display"
	SEGMENT ROM_TEXT
L__84:
	DB	"1 Incorrect format, hex [decimal number]"
	DB	10,0
	SEGMENT CODE
;  312	
;  313	static void cli_command_hex(char *args)
;  314	{
_cli_command_hex:
.define "_cli_command_hex"
.value _cli_command_hex
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_hex",314,"_cli_command_hex"
	LINK	#8
.line 314
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
.define "value"
.class 1
.value -8
.type 5
.type 0
.endef
;  315		char *token;
;  316		int value;
;  317	
;  318		cli_strip_spaces(&args);
.line 318
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  319	
;  320		token = args;
.line 320
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  321		if(cli_strip_decimal_number(&args)) {
.line 321
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_13_L_80
;  322			uart_printf("1 Incorrect format, hex [decimal number]\n");
.line 322
	PUSH.W	#L__84
	CALL	_uart_printf
	ADD	R15,#2
;  323			return;
.line 323
	JP	_13_L_81
;  324		}
_13_L_80:
.line 324
;  325	
;  326		value = atoi(token);
.line 326
	LD.SW	R1,-4(R14)
	CALL	_atoi
	LD	-8(R14),R0
;  327		led_display_int_hex(value);
.line 327
	LD	R1,-8(R14)
	CALL	_led_display_int_hex
;  328	}
_13_L_81:
.line 328
	UNLINK	
	RET	


;**************************** _cli_command_hex ***************************
;Name                         Addr/Register   Size   Type
;_led_display_int_hex                IMPORT  -----   function
;_atoi                               IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;value                                R14-8      4   variable
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "cli_command_hex",328,"_cli_command_hex"
	SEGMENT ROM_TEXT
L__87:
	DB	"1 Incorrect format, set prompt [\"text\"]"
	DB	10,0
L__88:
	DB	"prompt"
	DB	0
L__91:
	DB	"2 Incorrect format, set prompt [\"text\"]"
	DB	10,0
L__92:
	DB	"3 Incorrect format, set prompt [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  329	
;  330	static void cli_command_set(char *args)
;  331	{
_cli_command_set:
.define "_cli_command_set"
.value _cli_command_set
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_set",331,"_cli_command_set"
	LINK	#4
.line 331
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
;  332		char *token;
;  333	
;  334		cli_strip_spaces(&args);
.line 334
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  335	
;  336		token = args;
.line 336
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  337		if(cli_strip_word(&args)) {
.line 337
	LEA	R1,-2(R14)
	CALL	_cli_strip_word
	CP	R0,#0
	JP	EQ,_14_L_87
;  338			uart_printf("1 Incorrect format, set prompt [\"text\"]\n");
.line 338
	PUSH.W	#L__87
	CALL	_uart_printf
	ADD	R15,#2
;  339			return;
.line 339
	JP	_14_L_88
;  340		}
_14_L_87:
.line 340
;  341	
;  342		if(strcmp(token, "prompt") == 0) {
.line 342
	LD.SW	R1,-4(R14)
	LD	R2,#L__88
	CALL	_strcmp
	CP	R0,#0
	JP	NE,_14_L_86
;  343			++args;
.line 343
	INC.W	-2(R14)
;  344			cli_strip_spaces(&args);
.line 344
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  345	
;  346			token = args;
.line 346
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  347			if(cli_strip_quotes(&args)) {
.line 347
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_14_L_84
;  348				uart_printf("2 Incorrect format, set prompt [\"text\"]\n");
.line 348
	PUSH.W	#L__91
	CALL	_uart_printf
	ADD	R15,#2
;  349				return;
.line 349
	JP	_14_L_88
;  350			}
_14_L_84:
.line 350
;  351	
;  352			cli_set_prompt(++token);
.line 352
	INC.W	-4(R14)
	LD.SW	R1,-4(R14)
	CALL	_cli_set_prompt
;  353		}
;  354		else {
.line 354
	JP	_14_L_88
_14_L_86:
;  355			uart_printf("3 Incorrect format, set prompt [\"text\"]\n");
.line 355
	PUSH.W	#L__92
	CALL	_uart_printf
	ADD	R15,#2
;  356			return;
;  357		}
;  358	}
_14_L_88:
.line 358
	UNLINK	
	RET	


;**************************** _cli_command_set ***************************
;Name                         Addr/Register   Size   Type
;_cli_set_prompt                     IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_strcmp                             IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_word                     IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -4 (words)


.endfunc "cli_command_set",358,"_cli_command_set"
	SEGMENT ROM_TEXT
L__95:
	DB	"1 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
L__98:
	DB	"2 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
L__100:
	DB	"3 Incorrect format, switch [n] [\"text\"]"
	DB	10,0
	SEGMENT CODE
;  359	
;  360	static void cli_command_switch(char *args)
;  361	{
_cli_command_switch:
.define "_cli_command_switch"
.value _cli_command_switch
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_switch",361,"_cli_command_switch"
	LINK	#8
.line 361
	LD.W	-2(R14),R1
.define "args"
.class 9
.value -2
.type 140
.type 0
.endef
.define "token"
.class 1
.value -4
.type 140
.type 0
.endef
.define "value"
.class 1
.value -8
.type 5
.type 0
.endef
;  362		char *token;
;  363		int value;
;  364	
;  365		cli_strip_spaces(&args);
.line 365
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  366	
;  367		token = args;
.line 367
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  368		if(cli_strip_decimal_number(&args)) {
.line 368
	LEA	R1,-2(R14)
	CALL	_cli_strip_decimal_number
	CP	R0,#0
	JP	EQ,_15_L_90
;  369			uart_printf("1 Incorrect format, switch [n] [\"text\"]\n");
.line 369
	PUSH.W	#L__95
	CALL	_uart_printf
	ADD	R15,#2
;  370			return;
.line 370
	JP	_15_L_96
;  371		}
_15_L_90:
.line 371
;  372		value = atoi(token);
.line 372
	LD.SW	R1,-4(R14)
	CALL	_atoi
	LD	-8(R14),R0
;  373	
;  374		if(value < 0 || value >= MACRO_MAX) {
.line 374
	CPZ	-8(R14)
	JP	LT,_15_L_92
	LD	R0,#3
	CP	-8(R14),R0
	JP	LT,_15_L_93
_15_L_92:
;  375			uart_printf("2 Incorrect format, switch [n] [\"text\"]\n");
.line 375
	PUSH.W	#L__98
	CALL	_uart_printf
	ADD	R15,#2
;  376			return;
.line 376
	JP	_15_L_96
;  377		}
_15_L_93:
.line 377
;  378	
;  379		++args;
.line 379
	INC.W	-2(R14)
;  380		cli_strip_spaces(&args);
.line 380
	LEA	R1,-2(R14)
	CALL	_cli_strip_spaces
;  381	
;  382		token = args;
.line 382
	LD.SW	R0,-2(R14)
	LD.W	-4(R14),R0
;  383		if(cli_strip_quotes(&args)) {
.line 383
	LEA	R1,-2(R14)
	CALL	_cli_strip_quotes
	CP	R0,#0
	JP	EQ,_15_L_95
;  384			uart_printf("3 Incorrect format, switch [n] [\"text\"]\n");
.line 384
	PUSH.W	#L__100
	CALL	_uart_printf
	ADD	R15,#2
;  385			return;
.line 385
	JP	_15_L_96
;  386		}
_15_L_95:
.line 386
;  387	
;  388		macro_set(value, ++token);
.line 388
	INC.W	-4(R14)
	LD	R1,-8(R14)
	LD.SW	R2,-4(R14)
	CALL	_macro_set
;  389	}
_15_L_96:
.line 389
	UNLINK	
	RET	


;**************************** _cli_command_switch ***************************
;Name                         Addr/Register   Size   Type
;_macro_set                          IMPORT  -----   function
;_cli_strip_quotes                   IMPORT  -----   function
;_atoi                               IMPORT  -----   function
;_uart_printf                        IMPORT  -----   function
;_cli_strip_decimal_number           IMPORT  -----   function
;_cli_strip_spaces                   IMPORT  -----   function
;value                                R14-8      4   variable
;token                                R14-4      2   variable
;args                                 R14-2      2   parameter


; Aggregate Stack Size: -8 (words)


.endfunc "cli_command_switch",389,"_cli_command_switch"
;  390	
;  391	static void cli_command_port(char *args)
;  392	{
_cli_command_port:
.define "_cli_command_port"
.value _cli_command_port
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_port",392,"_cli_command_port"
.line 392
.define "args"
.class 17
.reg 2
.type 140
.type 0
.endef
	LINK	#0
;  393		
;  394	}
.line 394
	UNLINK	
	RET	


;**************************** _cli_command_port ***************************
;Name                         Addr/Register   Size   Type
;args                                    R1      2   parameter


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_port",394,"_cli_command_port"
;  395	
;  396	static void cli_command_timer(char *args)
;  397	{
_cli_command_timer:
.define "_cli_command_timer"
.value _cli_command_timer
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_timer",397,"_cli_command_timer"
.line 397
.define "args"
.class 17
.reg 2
.type 140
.type 0
.endef
	LINK	#0
;  398		
;  399	}
.line 399
	UNLINK	
	RET	


;**************************** _cli_command_timer ***************************
;Name                         Addr/Register   Size   Type
;args                                    R1      2   parameter


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_timer",399,"_cli_command_timer"
;  400	
;  401	static void cli_command_uart0(char *args)
;  402	{
_cli_command_uart0:
.define "_cli_command_uart0"
.value _cli_command_uart0
.class 3
.type 65
.type 0
.endef
.begfunc "cli_command_uart0",402,"_cli_command_uart0"
.line 402
.define "args"
.class 17
.reg 2
.type 140
.type 0
.endef
	LINK	#0
;  403		
.line 404
	UNLINK	
	RET	


;**************************** _cli_command_uart0 ***************************
;Name                         Addr/Register   Size   Type
;args                                    R1      2   parameter


; Aggregate Stack Size: 0 (words)


.endfunc "cli_command_uart0",404,"_cli_command_uart0"
	XREF _isspace:EROM
	XREF _isgraph:EROM
	XREF _isdigit:EROM
	XREF _isalpha:EROM
	XREF _memset:EROM
	XREF _memcpy:EROM
	XREF _strlen:EROM
	XREF _strchr:EROM
	XREF _strcmp:EROM
	XREF _strcpy:EROM
	XREF _atoi:EROM
	XREF _macro_set:EROM
	XREF _info_display:EROM
	XREF _init_info:EROM
	XREF _uart_printf:EROM
	XREF _uart_getchar:EROM
	XREF _init_uart:EROM
	XREF _led_display_int_hex:EROM
	XREF _led_display_text:EROM
	XREF _init_leds:EROM
	XDEF _cli_set_prompt
	XDEF _cli_strip_spaces
	XDEF _cli_strip_decimal_number
	XDEF _cli_strip_word
	XDEF _cli_strip_quotes
	XDEF _cli_loop
	XDEF _init_cli
	END
