ZiLOG ZNeo ANSI C Compiler Version 1.10	Mar  1 2011	04:58:45	page: 1
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

     1	    1	#include "uart.h"
     2	   45	
     3	   46	#include <zneo.h>
     4	  572	#include <string.h>
     5	  664	#include <stdio.h>
     6	 1510	#include <stdarg.h>
     7	 1526	
     8	 1527	#define BUFFER_SIZE 512
     9	 1528	
    10	 1529	#define FREQ         5529600UL  //use internal oscillator
    11	 1530	#define DEFAULT_BAUD 57600UL    //our desired baud rate
    12	 1531	
    13	 1532	//alternate function enable for PA for uart0
    14	 1533	#define PORTA_UART_RXD	0x10	
    15	 1534	#define PORTA_UART_TXD	0x20
    16	 1535	
    17	 1536	#define UART_TXD_EN		0x80	//transmit enable
    18	 1537	#define UART_RXD_EN		0x40	//receive enable
    19	 1538	
    20	 1539	#define UART_TRAN_RDY 0x04
    21	 1540	
    22	 1541	#define UART_IRQ_EN   0x18
    23	 1542	
    24	 1543	#define UART_IRQ_TRAN 0x08
    25	 1544	#define UART_IRQ_REC  0x10
    26	 1545	
    27	 1546	static unsigned char trans_buffer[BUFFER_SIZE];
    28	 1547	static unsigned char rec_buffer[BUFFER_SIZE];
    29	 1548	
    30	 1549	static volatile int trans_buffer_size;
    31	 1550	static volatile int rec_buffer_size;
    32	 1551	
    33	 1552	static volatile int trans_buffer_current;
    34	 1553	static volatile int rec_buffer_current;
    35	 1554	
    36	 1555	static unsigned long baud_rate;
    37	 1556	
    38	 1557	void interrupt uart_receive(void)
    39	 1558	{
    40	 1559		int buffer_loc;
    41	 1560		unsigned char c;
    42	 1561	
    43	 1562		c = U0RXD;
    44	 1563	
    45	 1564		//so the echo is compatible with Windows, CR+LF
    46	 1565		if(c == '\r' || c == '\n') {
    47	 1566			c = '\n';
    48	 1567			uart_putchar('\r');
    49	 1568			uart_putchar('\n');	
    50	 1569		}
    51	 1570		//echo the character back
    52	 1571		else {
    53	 1572			uart_putchar(c);
    54	 1573		}
    55	 1574	
ZiLOG ZNeo ANSI C Compiler Version 1.10	Mar  1 2011	04:58:45	page: 2
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

    56	 1575		if(rec_buffer_size < BUFFER_SIZE) {
    57	 1576			buffer_loc = (rec_buffer_current + rec_buffer_size) % BUFFER_SIZE;
    58	 1577			
    59	 1578			rec_buffer[buffer_loc] = c;
    60	 1579			++rec_buffer_size;
    61	 1580		}
    62	 1581	}
    63	 1582	
    64	 1583	void interrupt uart_transfer(void)
    65	 1584	{
    66	 1585		if(trans_buffer_size) {
    67	 1586			U0TXD = trans_buffer[trans_buffer_current];
    68	 1587	
    69	 1588			trans_buffer_current = (trans_buffer_current + 1) % BUFFER_SIZE;
    70	 1589			trans_buffer_size--;
    71	 1590		}
    72	 1591	}
    73	 1592	
    74	 1593	/*
    75	 1594		Configure UART0.
    76	 1595	 */
    77	 1596	void init_uart(void)
    78	 1597	{
    79	 1598		memset(rec_buffer, 0, BUFFER_SIZE);
    80	 1599		memset(trans_buffer, 0, BUFFER_SIZE);
    81	 1600	
    82	 1601		// Set the alternate function on port A
    83	 1602	    // Enable UART0 TxD0/RxD0 pins (bits 4 & 5)
    84	 1603		PAAFH &= ~(PORTA_UART_TXD | PORTA_UART_RXD);
    85	 1604	    PAAFL |= PORTA_UART_TXD | PORTA_UART_RXD;
    86	 1605	
    87	 1606	    // Set the baud rate
    88	 1607	    // BRG = freq/( baud * 16)
    89	 1608	    U0BR = FREQ/((unsigned long)DEFAULT_BAUD * 16UL);
    90	 1609		baud_rate = DEFAULT_BAUD;
    91	 1610	
    92	 1611	    // U0 control
    93	 1612	    // Transmit enable, Receive Enable, No Parity, 1 Stop
    94	 1613	    U0CTL0 = UART_RXD_EN | UART_TXD_EN;
    95	 1614	    U0CTL1 = 0;
    96	 1615	
    97	 1616		//set nominal priority
    98	 1617		IRQ0ENH |= UART_IRQ_EN;
    99	 1618		IRQ0ENL &= ~UART_IRQ_EN;
   100	 1619	
   101	 1620		PAIMUX &= ~UART_IRQ_EN;		//Port A (0) for interrupts
   102	 1621		PAIEDGE &= ~UART_IRQ_EN;	//negedge (0) interrupt
   103	 1622	
   104	 1623		SET_VECTOR(UART0_RX, uart_receive);
   105	 1624		SET_VECTOR(UART0_TX, uart_transfer);
   106	 1625	}
   107	 1626	
   108	 1627	int uart_putchar(unsigned char c)
   109	 1628	{
   110	 1629		int buffer_loc;
ZiLOG ZNeo ANSI C Compiler Version 1.10	Mar  1 2011	04:58:45	page: 3
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

   111	 1630	
   112	 1631		if(c == '\n') {
   113	 1632			while(uart_putchar('\r')) { ; }
   114	 1633		}
   115	 1634	
   116	 1635		if(trans_buffer_size < BUFFER_SIZE) {
   117	 1636			DI();
   118	 1637			
   119	 1638			buffer_loc = (trans_buffer_current + trans_buffer_size) % BUFFER_SIZE;
   120	 1639			trans_buffer[buffer_loc] = c;
   121	 1640			trans_buffer_size++;
   122	 1641	
   123	 1642			//trigger the interrupt if already ready to transmit
   124	 1643			if((U0STAT0 & UART_TRAN_RDY) && 
   125	 1644			   ((IRQ0SET & UART_IRQ_TRAN) == 0)) {
   126	 1645				IRQ0SET |= UART_IRQ_TRAN;
   127	 1646			}
   128	 1647	
   129	 1648			EI();
   130	 1649		}
   131	 1650		else {
   132	 1651			return 1;
   133	 1652		}
   134	 1653	
   135	 1654		return 0;
   136	 1655	}
   137	 1656	
   138	 1657	unsigned char uart_getchar(void)
   139	 1658	{
   140	 1659		unsigned char c;
   141	 1660	
   142	 1661		if(rec_buffer_size) {
   143	 1662			DI();
   144	 1663	
   145	 1664			c = rec_buffer[rec_buffer_current];
   146	 1665			rec_buffer_current = (rec_buffer_current + 1) % BUFFER_SIZE;
   147	 1666			rec_buffer_size--;
   148	 1667	
   149	 1668			EI();
   150	 1669	
   151	 1670			return c;
   152	 1671		}
   153	 1672	
   154	 1673		return 0;
   155	 1674	}
   156	 1675	
   157	 1676	void uart_printf(const char *format, ...)
   158	 1677	{
   159	 1678		char buffer[BUFFER_SIZE];
   160	 1679		va_list args;
   161	 1680		int i;
   162	 1681	
   163	 1682		va_start(args, format);
   164	 1683		vsprintf(buffer, format, args);
   165	 1684		va_end(args);
ZiLOG ZNeo ANSI C Compiler Version 1.10	Mar  1 2011	04:58:45	page: 4
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

   166	 1685	
   167	 1686		uart_transfer_msg(buffer);
   168	 1687	}
   169	 1688	
   170	 1689	void uart_transfer_msg(char *text)
   171	 1690	{
   172	 1691		int i;
   173	 1692		char *msg;
   174	 1693		
   175	 1694		msg = text;
   176	 1695		for(i = 0; *msg && i < BUFFER_SIZE; i++) {
   177	 1696			while(uart_putchar(*msg)) { ; }	//wait if the buffer is full
   178	 1697			msg++;
   179	 1698		}
   180	 1699	}
   181	 1700	
   182	 1701	unsigned long uart_get_baud_rate(void)
   183	 1702	{
   184	 1703		return baud_rate;
   185	 1704	}
   186	 1705	
   187	 1706	void uart_dummy_receive(char c)
   188	 1707	{
   189	 1708		int buffer_loc;
   190	 1709	
   191	 1710		DI();
   192	 1711	
   193	 1712		if(rec_buffer_size < BUFFER_SIZE) {
   194	 1713			buffer_loc = (rec_buffer_current + rec_buffer_size) % BUFFER_SIZE;
   195	 1714			
   196	 1715			rec_buffer[buffer_loc] = c;
   197	 1716			++rec_buffer_size;
   198	 1717		}
   199	 1718	
   200	 1719		EI();
   201	 1720	}ÿ
