ZiLOG ZNeo ANSI C Compiler Version 1.10	Feb 27 2011	17:33:57	page: 1
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

     1	    1	#include "uart.h"
     2	   38	
     3	   39	#include <zneo.h>
     4	  565	#include <string.h>
     5	  657	#include <stdio.h>
     6	 1503	#include <stdarg.h>
     7	 1519	
     8	 1520	#define BUFFER_SIZE 512
     9	 1521	
    10	 1522	#define FREQ         5529600UL  //use internal oscillator
    11	 1523	#define DEFAULT_BAUD 57600UL    //our desired baud rate
    12	 1524	
    13	 1525	//alternate function enable for PA for uart0
    14	 1526	#define PORTA_UART_RXD	0x10	
    15	 1527	#define PORTA_UART_TXD	0x20
    16	 1528	
    17	 1529	#define UART_TXD_EN		0x80	//transmit enable
    18	 1530	#define UART_RXD_EN		0x40	//receive enable
    19	 1531	
    20	 1532	#define UART_TRAN_RDY 0x04
    21	 1533	
    22	 1534	#define UART_IRQ_EN   0x18
    23	 1535	
    24	 1536	#define UART_IRQ_TRAN 0x08
    25	 1537	#define UART_IRQ_REC  0x10
    26	 1538	
    27	 1539	static unsigned char trans_buffer[BUFFER_SIZE];
    28	 1540	static unsigned char rec_buffer[BUFFER_SIZE];
    29	 1541	
    30	 1542	static volatile int trans_buffer_size;
    31	 1543	static volatile int rec_buffer_size;
    32	 1544	
    33	 1545	static volatile int trans_buffer_current;
    34	 1546	static volatile int rec_buffer_current;
    35	 1547	
    36	 1548	static unsigned long baud_rate;
    37	 1549	
    38	 1550	void interrupt uart_receive(void)
    39	 1551	{
    40	 1552		int buffer_loc;
    41	 1553		unsigned char c;
    42	 1554	
    43	 1555		c = U0RXD;
    44	 1556	
    45	 1557		//so the echo is compatible with Windows, CR+LF
    46	 1558		if(c == '\r' || c == '\n') {
    47	 1559			c = '\n';
    48	 1560			uart_putchar('\r');
    49	 1561			uart_putchar('\n');	
    50	 1562		}
    51	 1563		//echo the character back
    52	 1564		else {
    53	 1565			uart_putchar(c);
    54	 1566		}
    55	 1567	
ZiLOG ZNeo ANSI C Compiler Version 1.10	Feb 27 2011	17:33:57	page: 2
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

    56	 1568		if(rec_buffer_size < BUFFER_SIZE) {
    57	 1569			buffer_loc = (rec_buffer_current + rec_buffer_size) % BUFFER_SIZE;
    58	 1570			
    59	 1571			rec_buffer[buffer_loc] = c;
    60	 1572			++rec_buffer_size;
    61	 1573		}
    62	 1574	}
    63	 1575	
    64	 1576	void interrupt uart_transfer(void)
    65	 1577	{
    66	 1578		if(trans_buffer_size) {
    67	 1579			U0TXD = trans_buffer[trans_buffer_current];
    68	 1580	
    69	 1581			trans_buffer_current = (trans_buffer_current + 1) % BUFFER_SIZE;
    70	 1582			trans_buffer_size--;
    71	 1583		}
    72	 1584	}
    73	 1585	
    74	 1586	/*
    75	 1587		Configure UART0.
    76	 1588	 */
    77	 1589	void init_uart(void)
    78	 1590	{
    79	 1591		memset(rec_buffer, 0, BUFFER_SIZE);
    80	 1592		memset(trans_buffer, 0, BUFFER_SIZE);
    81	 1593	
    82	 1594		// Set the alternate function on port A
    83	 1595	    // Enable UART0 TxD0/RxD0 pins (bits 4 & 5)
    84	 1596		PAAFH &= ~(PORTA_UART_TXD | PORTA_UART_RXD);
    85	 1597	    PAAFL |= PORTA_UART_TXD | PORTA_UART_RXD;
    86	 1598	
    87	 1599	    // Set the baud rate
    88	 1600	    // BRG = freq/( baud * 16)
    89	 1601	    U0BR = FREQ/((unsigned long)DEFAULT_BAUD * 16UL);
    90	 1602		baud_rate = DEFAULT_BAUD;
    91	 1603	
    92	 1604	    // U0 control
    93	 1605	    // Transmit enable, Receive Enable, No Parity, 1 Stop
    94	 1606	    U0CTL0 = UART_RXD_EN | UART_TXD_EN;
    95	 1607	    U0CTL1 = 0;
    96	 1608	
    97	 1609		//set nominal priority
    98	 1610		IRQ0ENH |= UART_IRQ_EN;
    99	 1611		IRQ0ENL &= ~UART_IRQ_EN;
   100	 1612	
   101	 1613		PAIMUX &= ~UART_IRQ_EN;		//Port A (0) for interrupts
   102	 1614		PAIEDGE &= ~UART_IRQ_EN;	//negedge (0) interrupt
   103	 1615	
   104	 1616		SET_VECTOR(UART0_RX, uart_receive);
   105	 1617		SET_VECTOR(UART0_TX, uart_transfer);
   106	 1618	}
   107	 1619	
   108	 1620	int uart_putchar(unsigned char c)
   109	 1621	{
   110	 1622		int buffer_loc;
ZiLOG ZNeo ANSI C Compiler Version 1.10	Feb 27 2011	17:33:57	page: 3
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

   111	 1623	
   112	 1624		if(c == '\n') {
   113	 1625			while(uart_putchar('\r')) { ; }
   114	 1626		}
   115	 1627	
   116	 1628		if(trans_buffer_size < BUFFER_SIZE) {
   117	 1629			DI();
   118	 1630			
   119	 1631			buffer_loc = (trans_buffer_current + trans_buffer_size) % BUFFER_SIZE;
   120	 1632			trans_buffer[buffer_loc] = c;
   121	 1633			trans_buffer_size++;
   122	 1634	
   123	 1635			//trigger the interrupt if already ready to transmit
   124	 1636			if((U0STAT0 & UART_TRAN_RDY) && 
   125	 1637			   ((IRQ0SET & UART_IRQ_TRAN) == 0)) {
   126	 1638				IRQ0SET |= UART_IRQ_TRAN;
   127	 1639			}
   128	 1640	
   129	 1641			EI();
   130	 1642		}
   131	 1643		else {
   132	 1644			return 1;
   133	 1645		}
   134	 1646	
   135	 1647		return 0;
   136	 1648	}
   137	 1649	
   138	 1650	unsigned char uart_getchar(void)
   139	 1651	{
   140	 1652		unsigned char c;
   141	 1653	
   142	 1654		if(rec_buffer_size) {
   143	 1655			DI();
   144	 1656	
   145	 1657			c = rec_buffer[rec_buffer_current];
   146	 1658			rec_buffer_current = (rec_buffer_current + 1) % BUFFER_SIZE;
   147	 1659			rec_buffer_size--;
   148	 1660	
   149	 1661			EI();
   150	 1662	
   151	 1663			return c;
   152	 1664		}
   153	 1665	
   154	 1666		return 0;
   155	 1667	}
   156	 1668	
   157	 1669	void uart_printf(const char *format, ...)
   158	 1670	{
   159	 1671		char buffer[BUFFER_SIZE];
   160	 1672		va_list args;
   161	 1673		int i;
   162	 1674	
   163	 1675		va_start(args, format);
   164	 1676		vsprintf(buffer, format, args);
   165	 1677		va_end(args);
ZiLOG ZNeo ANSI C Compiler Version 1.10	Feb 27 2011	17:33:57	page: 4
Local	Global	File: C:\USERS\MATT\DOCUMENTS\CSCI-4415-LABS\HARLAN-LAB3\UART.C

   166	 1678	
   167	 1679		uart_transfer_msg(buffer);
   168	 1680	}
   169	 1681	
   170	 1682	void uart_transfer_msg(char *text)
   171	 1683	{
   172	 1684		int i;
   173	 1685		char *msg;
   174	 1686		
   175	 1687		msg = text;
   176	 1688		for(i = 0; *msg && i < BUFFER_SIZE; i++) {
   177	 1689			while(uart_putchar(*msg)) { ; }	//wait if the buffer is full
   178	 1690			msg++;
   179	 1691		}
   180	 1692	}
   181	 1693	
   182	 1694	unsigned long uart_get_baud_rate(void)
   183	 1695	{
   184	 1696		return baud_rate;
   185	 1697	}
   186	 1698	ÿ
